<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Flink从入门到放弃02——Flink简单上手</title>
    <url>/2021/12/10/Flink%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%8302%E2%80%94%E2%80%94Flink%E7%AE%80%E5%8D%95%E4%B8%8A%E6%89%8B/</url>
    <content><![CDATA[<p>上一篇简单介绍了Flink的主要情况和基本概念，这一篇通过宇宙通用的wordcount样例来了解下Flink的基本使用情况。主要上手实现三个样例程序：批处理WordCount，流处理WordCount和模拟Flink集群环境的流数据处理程序。介绍不同模式下的一些区别和问题。</p>
<a id="more"></a>

<h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><p>创建Flink项目FlinkTutorial -&gt; 编辑pom.xml文件，添加Flink项目依赖 </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.10.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- flink runtime组件用到akka,akka底层采用scala实现，因此需要指定一个scala版本，2.12--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.apache.flink<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>flink-streaming-java_2.12<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.10.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>其中第二个包中的 <code>_2.12</code> 是scala版本，为什么java实现的flink-streaming包需要添加scala版本信息，是因为其中依赖的runtime组件用到了基于scala实现的akka。</p>
<h1 id="批处理"><a href="#批处理" class="headerlink" title="批处理"></a>批处理</h1><h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.joy.wc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.common.functions.FlatMapFunction;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.java.DataSet;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.java.ExecutionEnvironment;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.java.tuple.Tuple2;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.util.Collector;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> * User: joy</span></span><br><span class="line"><span class="comment"> * Date: 2021/12/9</span></span><br><span class="line"><span class="comment"> * Time: 6:08 PM</span></span><br><span class="line"><span class="comment"> * Description: No Description</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 批处理wordcount</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WordCount</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 创建&quot;执行环境&quot;，类似spark的sc</span></span><br><span class="line">        ExecutionEnvironment env = ExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line">        <span class="comment">// 从文件中读取数据</span></span><br><span class="line">        String inputPath = <span class="string">&quot;/Users/joy/study/0. 其他/flink/4.代码/FlinkTutorial/src/main/resources/hello.txt&quot;</span>;</span><br><span class="line">        DataSet&lt;String&gt; inputDataset = env.readTextFile(inputPath);</span><br><span class="line">        <span class="comment">// 处理数据集，分词、转换</span></span><br><span class="line">        DataSet&lt;Tuple2&lt;String, Integer&gt;&gt; resultDataSet = inputDataset.flatMap(<span class="keyword">new</span> MyFlatMapper() &#123;&#125;)</span><br><span class="line">                .groupBy(<span class="number">0</span>) <span class="comment">// 按照第一个位置的word分组;</span></span><br><span class="line">                .sum(<span class="number">1</span>);<span class="comment">// 第2个位置数值求和</span></span><br><span class="line"></span><br><span class="line">        resultDataSet.print();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义类，实现FlatMapFunction接口</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFlatMapper</span> <span class="keyword">implements</span> <span class="title">FlatMapFunction</span>&lt;<span class="title">String</span>, <span class="title">Tuple2</span>&lt;<span class="title">String</span>, <span class="title">Integer</span>&gt;&gt;</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatMap</span><span class="params">(String value, Collector&lt;Tuple2&lt;String, Integer&gt;&gt; out)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">// 按空格分词</span></span><br><span class="line">            String[] words = value.split(<span class="string">&quot; &quot;</span>);</span><br><span class="line">            <span class="comment">// 遍历所有word包成二元组输出</span></span><br><span class="line">            <span class="keyword">for</span>(String word: words)&#123;</span><br><span class="line">                out.collect(<span class="keyword">new</span> Tuple2&lt;&gt;(word, <span class="number">1</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输入：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 文件 text.txt</span></span><br><span class="line">hello world</span><br><span class="line">hello flink</span><br><span class="line">hello spark</span><br><span class="line">hello scala</span><br><span class="line">how are you</span><br><span class="line">fine thank you</span><br><span class="line">and you</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight lisp"><table><tr><td class="code"><pre><span class="line">(<span class="name">and</span>,<span class="number">1</span>)</span><br><span class="line">(<span class="name">are</span>,<span class="number">1</span>)</span><br><span class="line">(<span class="name">scala</span>,<span class="number">1</span>)</span><br><span class="line">(<span class="name">thank</span>,<span class="number">1</span>)</span><br><span class="line">(<span class="name">you</span>,<span class="number">3</span>)</span><br><span class="line">(<span class="name">fine</span>,<span class="number">1</span>)</span><br><span class="line">(<span class="name">flink</span>,<span class="number">1</span>)</span><br><span class="line">(<span class="name">world</span>,<span class="number">1</span>)</span><br><span class="line">(<span class="name">hello</span>,<span class="number">4</span>)</span><br><span class="line">(<span class="name">how</span>,<span class="number">1</span>)</span><br><span class="line">(<span class="name">spark</span>,<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">Process finished with exit code <span class="number">0</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="要点"><a href="#要点" class="headerlink" title="要点"></a>要点</h2><ul>
<li>DataSet数据结构</li>
</ul>
<p><code>env.readTextFile(inputPath); </code></p>
<p>操作获得的结果是DataSource，父类是DataSet，也就是批处理的底层数据类型。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> DataSource&lt;String&gt; <span class="title">readTextFile</span><span class="params">(String filePath)</span> </span>&#123;</span><br><span class="line">  Preconditions.checkNotNull(filePath, <span class="string">&quot;The file path may not be null.&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> DataSource(<span class="keyword">this</span>, <span class="keyword">new</span> TextInputFormat(<span class="keyword">new</span> Path(filePath)), 	BasicTypeInfo.STRING_TYPE_INFO, Utils.getCallLocationName());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DataSource</span>&lt;<span class="title">OUT</span>&gt; <span class="keyword">extends</span> <span class="title">Operator</span>&lt;<span class="title">OUT</span>, <span class="title">DataSource</span>&lt;<span class="title">OUT</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> InputFormat&lt;OUT, ?&gt; inputFormat;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String dataSourceLocationName;</span><br><span class="line">    <span class="keyword">private</span> Configuration parameters;</span><br><span class="line">    <span class="keyword">private</span> SplitDataProperties&lt;OUT&gt; splitDataProperties;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Operator</span>&lt;<span class="title">OUT</span>, <span class="title">O</span> <span class="keyword">extends</span> <span class="title">Operator</span>&lt;<span class="title">OUT</span>, <span class="title">O</span>&gt;&gt; <span class="keyword">extends</span> <span class="title">DataSet</span>&lt;<span class="title">OUT</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> parallelism = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">protected</span> ResourceSpec minResources;</span><br><span class="line">    <span class="keyword">protected</span> ResourceSpec preferredResources;</span><br><span class="line">    ……</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>FlatMap算子</li>
</ul>
<p>从源码可以看出，flatmap函数是一个Operator，其中 <code>FlatMapFunction</code> 是一个接口类，也就是说，flatMap函数的调用需要自定义函数实现接口，即上述代码中 <code>MyFlatMapper</code> 部分。</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;R&gt; <span class="function">FlatMapOperator&lt;T, R&gt; <span class="title">flatMap</span><span class="params">(FlatMapFunction&lt;T, R&gt; flatMapper)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (flatMapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">&quot;FlatMap function must not be null.&quot;</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    String callLocation = Utils.getCallLocationName();</span><br><span class="line">    TypeInformation&lt;R&gt; resultType = TypeExtractor.getFlatMapReturnTypes(flatMapper, <span class="keyword">this</span>.getType(), callLocation, <span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FlatMapOperator(<span class="keyword">this</span>, resultType, (FlatMapFunction)<span class="keyword">this</span>.clean(flatMapper), callLocation);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="meta">@Public</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">FlatMapFunction</span>&lt;<span class="title">T</span>, <span class="title">O</span>&gt; <span class="keyword">extends</span> <span class="title">Function</span>, <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">flatMap</span><span class="params">(T var1, Collector&lt;O&gt; var2)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="流处理"><a href="#流处理" class="headerlink" title="流处理"></a>流处理</h1><h2 id="完整代码-1"><a href="#完整代码-1" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.joy.wc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.java.tuple.Tuple2;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.DataStream;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> * User: joy</span></span><br><span class="line"><span class="comment"> * Date: 2021/12/9</span></span><br><span class="line"><span class="comment"> * Time: 6:40 PM</span></span><br><span class="line"><span class="comment"> * Description: No Description</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamWordCount</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 创建流处理执行环境</span></span><br><span class="line">        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().setParallelism(<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 读取数据</span></span><br><span class="line">        String inputPath = <span class="string">&quot;/Users/joy/study/0. 其他/flink/4.代码/FlinkTutorial/src/main/resources/hello.txt&quot;</span>;</span><br><span class="line">        DataStream&lt;String&gt; inputDataStream = env.readTextFile(inputPath);</span><br><span class="line">        <span class="comment">// 处理数据</span></span><br><span class="line">        DataStream&lt;Tuple2&lt;String, Integer&gt;&gt; resultStream = inputDataStream.flatMap(<span class="keyword">new</span> WordCount.MyFlatMapper())</span><br><span class="line">                .keyBy(<span class="number">0</span>)</span><br><span class="line">                .sum(<span class="number">1</span>);</span><br><span class="line">        resultStream.print(); <span class="comment">// 只把任务定义出来了，没有执行任务</span></span><br><span class="line">        <span class="comment">// 执行任务</span></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">3&gt;</span><span class="bash"> (world,1)</span></span><br><span class="line"><span class="meta">3&gt;</span><span class="bash"> (how,1)</span></span><br><span class="line"><span class="meta">3&gt;</span><span class="bash"> (you,1)</span></span><br><span class="line"><span class="meta">3&gt;</span><span class="bash"> (fine,1)</span></span><br><span class="line"><span class="meta">3&gt;</span><span class="bash"> (you,2)</span></span><br><span class="line"><span class="meta">2&gt;</span><span class="bash"> (are,1)</span></span><br><span class="line"><span class="meta">4&gt;</span><span class="bash"> (flink,1)</span></span><br><span class="line"><span class="meta">2&gt;</span><span class="bash"> (thank,1)</span></span><br><span class="line"><span class="meta">2&gt;</span><span class="bash"> (hello,1)</span></span><br><span class="line"><span class="meta">2&gt;</span><span class="bash"> (hello,2)</span></span><br><span class="line"><span class="meta">4&gt;</span><span class="bash"> (and,1)</span></span><br><span class="line"><span class="meta">3&gt;</span><span class="bash"> (you,3)</span></span><br><span class="line"><span class="meta">2&gt;</span><span class="bash"> (hello,3)</span></span><br><span class="line"><span class="meta">2&gt;</span><span class="bash"> (hello,4)</span></span><br><span class="line"><span class="meta">1&gt;</span><span class="bash"> (spark,1)</span></span><br><span class="line"><span class="meta">1&gt;</span><span class="bash"> (scala,1)</span></span><br></pre></td></tr></table></figure>
<ul>
<li>前面的 <code>3&gt;</code> 表示线程号，当前机器的默认并行度默认为4（核数），可以设置</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建流处理执行环境</span></span><br><span class="line">StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().setParallelism(<span class="number">8</span>);</span><br></pre></td></tr></table></figure>
<ul>
<li>不同的word出现多次</li>
</ul>
<h2 id="要点-1"><a href="#要点-1" class="headerlink" title="要点"></a>要点</h2><ul>
<li>创建执行环境采用StreamExecutionEnvironment（批处理采用ExecutionEnvironment）</li>
<li>数据类型为DataStream（批处理采用DataSet）</li>
<li>DataStream数据类型没有groupby算子只有keyby，即流式条件下，按照当前key的哈希code进行重分区的操作</li>
<li>由于任务是流式的，数据流是无界数据流，所以<code>.print()</code> 操作只是把任务定义出来了并没有执行。任务的执行需要  <code>execute()</code></li>
</ul>
<h1 id="端口监听式流处理"><a href="#端口监听式流处理" class="headerlink" title="端口监听式流处理"></a>端口监听式流处理</h1><h2 id="完整代码-2"><a href="#完整代码-2" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> cn.joy.wc;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.java.tuple.Tuple2;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.api.java.utils.ParameterTool;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.datastream.DataStream;</span><br><span class="line"><span class="keyword">import</span> org.apache.flink.streaming.api.environment.StreamExecutionEnvironment;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Created with IntelliJ IDEA.</span></span><br><span class="line"><span class="comment"> * User: joy</span></span><br><span class="line"><span class="comment"> * Date: 2021/12/9</span></span><br><span class="line"><span class="comment"> * Time: 6:57 PM</span></span><br><span class="line"><span class="comment"> * Description: No Description</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlinkWordCount</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// 创建流处理执行环境</span></span><br><span class="line">        StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment().setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 用parameter tool从程序启动(main 方法参数)参数中提取配置项</span></span><br><span class="line">        ParameterTool parameterTool = ParameterTool.fromArgs(args);</span><br><span class="line">        String host = parameterTool.get(<span class="string">&quot;host&quot;</span>);</span><br><span class="line">        <span class="keyword">int</span> port = parameterTool.getInt(<span class="string">&quot;port&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 从kafka消息队列中读取数据/netcat模拟</span></span><br><span class="line">        <span class="comment">// 从socket文本流读取数据</span></span><br><span class="line">        DataStream&lt;String&gt; inputDataStream = env.socketTextStream(host, port);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 处理数据</span></span><br><span class="line">        DataStream&lt;Tuple2&lt;String, Integer&gt;&gt; resultStream = inputDataStream.flatMap(<span class="keyword">new</span> WordCount.MyFlatMapper())</span><br><span class="line">                .keyBy(<span class="number">0</span>)</span><br><span class="line">                .sum(<span class="number">1</span>);</span><br><span class="line">        resultStream.print(); <span class="comment">// 只把任务定义出来了，没有执行任务</span></span><br><span class="line">        <span class="comment">// 执行任务</span></span><br><span class="line">        env.execute();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">端口输入：</span><br><span class="line">(base) ➜  ~ nc -lk 7777</span><br><span class="line">hello word</span><br><span class="line">test</span><br><span class="line">hello again</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">输出：</span><br><span class="line">(hello,1)</span><br><span class="line">(word,1)</span><br><span class="line">(test,1)</span><br><span class="line">(hello,2)</span><br><span class="line">(again,1)</span><br></pre></td></tr></table></figure>
<h2 id="要点-2"><a href="#要点-2" class="headerlink" title="要点"></a>要点</h2><ul>
<li>通过监听端口获取socket文本流</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">DataStream&lt;String&gt; inputDataStream = env.socketTextStream(host, port);</span><br></pre></td></tr></table></figure>
<ul>
<li>通过ParameterTool对主机和端口进行配置</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 用parameter tool从程序启动(main 方法参数)参数中提取配置项</span></span><br><span class="line">ParameterTool parameterTool = ParameterTool.fromArgs(args);</span><br><span class="line">String host = parameterTool.get(<span class="string">&quot;host&quot;</span>);</span><br><span class="line"><span class="keyword">int</span> port = parameterTool.getInt(<span class="string">&quot;port&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从kafka消息队列中读取数据/netcat模拟</span></span><br><span class="line"><span class="comment">// 从socket文本流读取数据</span></span><br><span class="line">DataStream&lt;String&gt; inputDataStream = env.socketTextStream(host, port);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<img data-src="/images/Flink%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%8302%E2%80%94%E2%80%94Flink%E7%AE%80%E5%8D%95%E4%B8%8A%E6%89%8B/image-20211209193329063.png" alt="image-20211209193329063" style="zoom: 50%;" />

]]></content>
      <categories>
        <category>BigData</category>
      </categories>
      <tags>
        <tag>Flink</tag>
      </tags>
  </entry>
  <entry>
    <title>HBase上手记录</title>
    <url>/2021/07/20/HBase%E4%B8%8A%E6%89%8B%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>HBase是一个分布式的、面向列的开源数据库，该技术来源于 Fay Chang 所撰写的Google论文“Bigtable：一个结构化数据的<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTUlODglODYlRTUlQjglODMlRTUlQkMlOEYlRTUlQUQlOTglRTUlODIlQTglRTclQjMlQkIlRTclQkIlOUYvNjYwODg3NQ==">分布式存储系统<i class="fa fa-external-link-alt"></i></span>”。就像Bigtable利用了Google文件系统（File System）所提供的分布式数据存储一样，HBase在Hadoop之上提供了类似于Bigtable的能力。HBase是Apache的Hadoop项目的子项目。HBase不同于一般的关系数据库，它是一个适合于非结构化数据存储的数据库。另一个不同的是HBase基于列的而不是基于行的模式。</p>
<a id="more"></a>

<h1 id="一、HBase是什么"><a href="#一、HBase是什么" class="headerlink" title="一、HBase是什么"></a>一、HBase是什么</h1><blockquote>
<p><span class="exturl" data-url="aHR0cHM6Ly9saW5rLnpoaWh1LmNvbS8/dGFyZ2V0PWh0dHBzOi8vd3d3LmFwYWNoZS5vcmcv">Apache<i class="fa fa-external-link-alt"></i></span> HBase™ is the <span class="exturl" data-url="aHR0cHM6Ly9saW5rLnpoaWh1LmNvbS8/dGFyZ2V0PWh0dHBzOi8vaGFkb29wLmFwYWNoZS5vcmcv">Hadoop<i class="fa fa-external-link-alt"></i></span> database, a distributed, scalable, big data store.<br>HBase is a type of “NoSQL” database.</p>
</blockquote>
<p>Apache HBase 是 Hadoop 数据库，一个分布式、可伸缩的<strong>大数据存储</strong>。</p>
<p>HBase是依赖Hadoop的。为什么HBase能存储海量的数据？<strong>因为HBase是在HDFS的基础之上构建的，HDFS是分布式文件系统</strong>。</p>
<h1 id="二、为什么用HBase"><a href="#二、为什么用HBase" class="headerlink" title="二、为什么用HBase"></a>二、为什么用HBase</h1><p>和其他组件相比：</p>
<ul>
<li>Mysql？单机，存储数据量取决于硬盘大小，扩展性不好</li>
<li>Kafka？主要用来处理消息（解耦、异步、削峰）。数据到kafka会被持久化到硬盘里，并且是分布式的，可以存储大量的数据，但是Kafka的数据一般不单独取出来。持久化了的数据，最常见的用法是重新设置offset，做回溯操作。</li>
<li>Redis？内存速度快，价格太贵</li>
<li>ES？Elasticsearch是分布式搜索引擎，但主要用于检索。如果没有经常见检索的需求，不必放到ES里，因为数据写入ES需要分词，浪费资源。</li>
<li>HDFS？无疑可以存储海量数据，但是不支持随机修改，查询效率低</li>
</ul>
<p>HBase的数据其实也是存储在HDFS上的。HDFS是文件系统，而HBase是数据库，其实也没啥可比性。「<strong>你可以把HBase当做是MySQL，把HDFS当做是硬盘。HBase只是一个NoSQL数据库，把数据存在HDFS上</strong>」。HBase在HDFS之上提供了<strong>高并发的随机写和支持实时查询</strong>，这是HDFS不具备的。HBase还有一个特点就是：<strong>存储数据的”结构“可以地非常灵活</strong>。</p>
<h1 id="三、入门HBase"><a href="#三、入门HBase" class="headerlink" title="三、入门HBase"></a>三、入门HBase</h1><h2 id="1-列式存储"><a href="#1-列式存储" class="headerlink" title="1. 列式存储"></a>1. 列式存储</h2><p><strong>什么是列式存储？</strong></p>
<p>MySQL存储的结构是典型的关系型数据库，数据是一行一行的形式。</p>
<img data-src="/images/HBase%E4%B8%8A%E6%89%8B%E8%AE%B0%E5%BD%95/v2-58697c09af0a80f04af4b2231e6a0813_720w.jpg" alt="v2-58697c09af0a80f04af4b2231e6a0813_720w" style="zoom:25%;" />

<p>换成列式存储</p>
<img data-src="/images/HBase%E4%B8%8A%E6%89%8B%E8%AE%B0%E5%BD%95/v2-8b4c896c9decec36b89e6b2fee968c6a_720w.jpg" alt="v2-8b4c896c9decec36b89e6b2fee968c6a_720w" style="zoom:25%;" />

<p>也就是把每列抽出来，关联上行ID。<strong>这样做的好处是，省空间</strong>。 以前我们一行记录多个属性(列)，有部分的列是空缺的，但是我们还是需要空间去存储。现在把这些列全部拆开，有什么我们就存什么，这样空间就能被我们充分利用。</p>
<p>这种形式更像<strong>Key-value</strong>。</p>
<h2 id="2-HBase的数据模型"><a href="#2-HBase的数据模型" class="headerlink" title="2. HBase的数据模型"></a>2. HBase的数据模型</h2><p>在HBase里边，定位一行数据会有一个唯一的值，这个叫做行键(RowKey)。而在HBase的列不是我们在关系型数据库所想象中的列。</p>
<p>HBase的列（Column）都得归属到列族（Column Family）中。在HBase中用列修饰符（Column Qualifier）来标识每个列。</p>
<p><strong>在HBase里边，先有列族，后有列</strong>。</p>
<p>什么是列族？可以简单理解为：列的属性类别</p>
<p>什么是列修饰符？先有列族后有列，在列族下用列修饰符来标识一列。</p>
<img data-src="/images/HBase%E4%B8%8A%E6%89%8B%E8%AE%B0%E5%BD%95/v2-1f69aa3a03c9666d5b613e5a0a5e70c4_720w.jpg" alt="v2-1f69aa3a03c9666d5b613e5a0a5e70c4_720w" style="zoom: 50%;" />

<p>HBase表的每一行中，列的组成都是<strong>灵活</strong>的，<strong>行与行之间的列不需要相同</strong>。如图下：</p>
<img data-src="/images/HBase%E4%B8%8A%E6%89%8B%E8%AE%B0%E5%BD%95/v2-fac481c6ec3efacce0ec3f3c7d127db0_720w.jpg" alt="img" style="zoom:33%;" />

<img data-src="/images/HBase%E4%B8%8A%E6%89%8B%E8%AE%B0%E5%BD%95/v2-de19abe0e27b1660e3474bd11aaf8d61_720w.jpg" alt="img" style="zoom: 50%;" />

<p>换句话说：<strong>一个列族下可以任意添加列，不受任何限制</strong></p>
<p><strong>数据写到HBase的时候都会被记录一个时间戳，这个时间戳被我们当做一个版本。比如说，我们修改或者删除某一条的时候，本质上是往里边新增一条数据，记录的版本加一了而已。</strong></p>
<p>比如现在我们有一条记录：</p>
<img data-src="/images/HBase%E4%B8%8A%E6%89%8B%E8%AE%B0%E5%BD%95/v2-433053cc5a4dfe5a9d26f9231cdaca5e_720w.jpg" alt="img" style="zoom: 50%;" />

<p>现在要把这条记录的值改为40，实际上就是多添加一条记录，在读的时候按照时间戳<strong>读最新</strong>的记录。在外界「看起来」就是把这条记录改了。</p>
<img data-src="/images/HBase%E4%B8%8A%E6%89%8B%E8%AE%B0%E5%BD%95/v2-a08e56a695e366a580c12514ffe09a21_720w.jpg" alt="img" style="zoom:50%;" />

<h2 id="3-HBase的Key-Value结构"><a href="#3-HBase的Key-Value结构" class="headerlink" title="3. HBase的Key-Value结构"></a>3. HBase的Key-Value结构</h2><p>HBase的Key-Value结构图：</p>
<img data-src="/images/HBase%E4%B8%8A%E6%89%8B%E8%AE%B0%E5%BD%95/v2-5c2c05489dc0c4af823d26641dc0e477_720w.jpg" alt="v2-5c2c05489dc0c4af823d26641dc0e477_720w" style="zoom: 50%;" />

<blockquote>
<p>Key = Row Key + Column Family + Column Qualifier + Time stamp + Key Type</p>
<p>Value是实际的字段值</p>
</blockquote>
<h2 id="4-HBase架构"><a href="#4-HBase架构" class="headerlink" title="4. HBase架构"></a>4. HBase架构</h2><p>架构图：</p>
<img data-src="/images/HBase%E4%B8%8A%E6%89%8B%E8%AE%B0%E5%BD%95/v2-f9029a2beaf2b07d9ae949013ddca351_720w.jpg" alt="v2-f9029a2beaf2b07d9ae949013ddca351_720w" style="zoom: 67%;" />

<p>1、<strong>Client</strong>客户端，它提供了访问HBase的接口，并且维护了对应的cache来加速HBase的访问。</p>
<p>2、<strong>Zookeeper</strong>存储HBase的元数据（meta表），无论是读还是写数据，都是去Zookeeper里边拿到meta元数据<strong>告诉给客户端去哪台机器读写数据</strong></p>
<p>3、<strong>HRegionServer</strong>它是处理客户端的读写请求，负责与HDFS底层交互，是真正干活的节点。</p>
<p>4、HMaster处理 HRegion 的分配或转移。如果我们HRegion的数据量太大的话，HMaster会对拆分后的Region<strong>重新分配RegionServer</strong>。HMaster会处理元数据的变更和监控RegionServer的状态。</p>
<p>总结大致的流程就是：<strong>client请求到Zookeeper，然后Zookeeper返回HRegionServer地址给client，client得到Zookeeper返回的地址去请求HRegionServer，HRegionServer读写数据后返回给client。</strong></p>
<p>HRegionServer内部结构图：</p>
<img data-src="/images/HBase%E4%B8%8A%E6%89%8B%E8%AE%B0%E5%BD%95/v2-a2bb5cd2216cb2b98d181d5eac1ca87f_720w.jpg" alt="v2-a2bb5cd2216cb2b98d181d5eac1ca87f_720w" style="zoom:80%;" />

<ul>
<li>一张hbase表按照RowKey进行横向切割，每个HRegionServer中包含多个<code>HRegion</code>，每个HRegion存储横向切割后的一部分数据。</li>
<li>每个HRegion中包含多个<code>store</code>，存储不同的列族。列是在列族之下的，列可以随意添加。</li>
<li>HBase在写数据的时候，会先写到<code>Mem Store</code>，当MemStore超过一定阈值，就会将内存中的数据刷写到硬盘上，形成StoreFile，而<code>StoreFile</code>底层是以HFile的格式保存，HFile是HBase中KeyValue数据的存储格式。Mem Store我们可以理解为内存 buffer，HFile是HBase实际存储的数据格式，而StoreFile只是HBase里的一个名字。</li>
<li>为了防止机器宕机，内存的数据没刷到磁盘中就挂了。我们在写Mem store的时候还会写一份<code>HLog</code>。</li>
</ul>
<h1 id="四、HBase实际操作"><a href="#四、HBase实际操作" class="headerlink" title="四、HBase实际操作"></a>四、HBase实际操作</h1><p>实验环境中已经基于docker安装了Hbase环境。<code>docker exec</code> 命令直接进入容器。<code>jps</code> 命令查看运行进程：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@bigdata-12 /]# jps</span><br><span class="line">34851 Jps</span><br><span class="line">37 HMaster</span><br><span class="line">123 HRegionServer</span><br><span class="line">269 RESTServer</span><br></pre></td></tr></table></figure>
<h2 id="1-HBase-shell操作"><a href="#1-HBase-shell操作" class="headerlink" title="1. HBase shell操作"></a>1. HBase shell操作</h2><p><code>hbase shell</code> 命令进入命令行，查看表格:</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">hbase(main):001:0&gt; list</span><br><span class="line">TABLE</span><br><span class="line">aaa</span><br><span class="line">bucket-0915</span><br><span class="line">entity_cert_serial</span><br><span class="line">entity_client_ip</span><br><span class="line">entity_file</span><br><span class="line">entity_fqdn</span><br><span class="line">entity_mail</span><br><span class="line">entity_qq_account</span><br><span class="line">entity_server_ip</span><br><span class="line">entity_user_id</span><br><span class="line">……</span><br></pre></td></tr></table></figure>
<p>创建表，表名hbase_1102，HBase表是由Key-Value组成的，此表中Key为NAME </p>
<img data-src="/images/HBase%E4%B8%8A%E6%89%8B%E8%AE%B0%E5%BD%95/726151-20170227162331001-824551785.png" alt="img" style="zoom:75%;" />

<p>此表有两个列族，CF1和CF2，其中CF1和CF2下分别有两个列name和gender，Chinese和Math<br>创建表hbase_1102有两个列族CF1和CF2</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">hbase(main):<span class="number">041</span>:<span class="number">0</span>&gt; <span class="keyword">create</span> <span class="string">&#x27;hbase_1102&#x27;</span>,  &#123;<span class="type">NAME</span>=&gt;<span class="string">&#x27;cf1&#x27;</span>&#125;, &#123;<span class="type">NAME</span>=&gt;<span class="string">&#x27;cf2&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>
<p>向表中添加数据，在想HBase的表中添加数据的时候，只能一列一列的添加，不能同时添加多列。</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">hbase</span><span class="params">(main)</span></span>:<span class="number">042</span>:<span class="number">0</span>&gt; put<span class="string">&#x27;hbase_1102&#x27;</span>, <span class="string">&#x27;001&#x27;</span>,<span class="string">&#x27;cf1:name&#x27;</span>,<span class="string">&#x27;Tom&#x27;</span></span><br><span class="line"><span class="function"><span class="title">hbase</span><span class="params">(main)</span></span>:<span class="number">043</span>:<span class="number">0</span>&gt; put<span class="string">&#x27;hbase_1102&#x27;</span>, <span class="string">&#x27;001&#x27;</span>,<span class="string">&#x27;cf1:gender&#x27;</span>,<span class="string">&#x27;man&#x27;</span></span><br><span class="line"><span class="function"><span class="title">hbase</span><span class="params">(main)</span></span>:<span class="number">044</span>:<span class="number">0</span>&gt; put<span class="string">&#x27;hbase_1102&#x27;</span>, <span class="string">&#x27;001&#x27;</span>,<span class="string">&#x27;cf2:chinese&#x27;</span>,<span class="string">&#x27;90&#x27;</span></span><br><span class="line"><span class="function"><span class="title">hbase</span><span class="params">(main)</span></span>:<span class="number">045</span>:<span class="number">0</span>&gt; put<span class="string">&#x27;hbase_1102&#x27;</span>, <span class="string">&#x27;001&#x27;</span>,<span class="string">&#x27;cf2:math&#x27;</span>,<span class="string">&#x27;91&#x27;</span></span><br></pre></td></tr></table></figure>
<p>这样表结构就起来了，其实比较自由，列族里边可以自由添加子列很方便。如果列族下没有子列，加不加冒号都是可以的。</p>
<p>如果在添加数据的时候，需要手动的设置时间戳，则在put命令的最后加上相应的时间戳，时间戳是long类型的，所以不需要加引号</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">hbase</span>(main):<span class="number">045</span>:<span class="number">0</span>&gt; put&#x27;hbase_<span class="number">1102</span>&#x27;, &#x27;<span class="number">001</span>&#x27;,&#x27;cf<span class="number">2</span>:math&#x27;,&#x27;<span class="number">91</span>&#x27;，<span class="number">1478053832459</span></span><br></pre></td></tr></table></figure>
<p>查看表中的所有数据</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">hbase(main):046:0&gt; scan <span class="string">&#x27;hbase_1102&#x27;</span></span><br><span class="line">ROW   COLUMN+CELL                                                             </span><br><span class="line"> 001  <span class="attribute">column</span>=cf1:gender, <span class="attribute">timestamp</span>=1478053832459, <span class="attribute">value</span>=man                   </span><br><span class="line"> 001  <span class="attribute">column</span>=cf1:name, <span class="attribute">timestamp</span>=1478053787178, <span class="attribute">value</span>=Tom                     </span><br><span class="line"> 001  <span class="attribute">column</span>=cf2:chinese, <span class="attribute">timestamp</span>=1478053848225, <span class="attribute">value</span>=90001  <span class="attribute">column</span>=cf2:math, <span class="attribute">timestamp</span>=1478053858144, <span class="attribute">value</span>=911 row(s) in0.0140seconds</span><br></pre></td></tr></table></figure>
<p>查看其中某一个Key的数据</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">hbase(main):048:0&gt; get<span class="string">&#x27;hbase_1102&#x27;</span>,<span class="string">&#x27;001&#x27;</span></span><br><span class="line">COLUMN                    CELL                                                                    </span><br><span class="line"> cf1:gender               <span class="attribute">timestamp</span>=1478053832459, <span class="attribute">value</span>=man                                      </span><br><span class="line"> cf1:name                 <span class="attribute">timestamp</span>=1478053787178, <span class="attribute">value</span>=Tom                                      </span><br><span class="line"> cf2:chinese              <span class="attribute">timestamp</span>=1478053848225, <span class="attribute">value</span>=90                                       </span><br><span class="line"> cf2:math                 <span class="attribute">timestamp</span>=1478053858144, <span class="attribute">value</span>=914 row(s) in0.0290seconds</span><br></pre></td></tr></table></figure>
<p>添加一个列族</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">alter &#x27;member&#x27;, &#x27;id&#x27;</span><br></pre></td></tr></table></figure>
<p>删除一个列族</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">alter &#x27;member&#x27;, &#123;NAME =&gt; &#x27;member_id&#x27;, METHOD =&gt; &#x27;delete’&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>bigdata</category>
      </categories>
      <tags>
        <tag>HBase</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux服务器安装Python3</title>
    <url>/2021/04/20/Linux%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%89%E8%A3%85Python3/</url>
    <content><![CDATA[<p>服务器Linux下默认系统自带python2.6的版本，这个版本被系统很多程序所依赖，所以不建议删除。如果使用最新的Python3那么我们知道编译安装源码包和系统默认包之间是没有任何影响的。根据工作需要在服务器上安装python3环境，相关操作步骤记录。</p>
<a id="more"></a>

<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>由于centos7原本就安装了Python2，而且这个Python2不能被删除，因为有很多系统命令，比如yum都要用到。</p>
<figure class="highlight csharp"><table><tr><td class="code"><pre><span class="line">[<span class="meta">root@iZuf6ititjgl7x9tgf1cyiZ ~</span>]<span class="meta"># python</span></span><br><span class="line">Python <span class="number">2.6</span><span class="number">.6</span> (r266:<span class="number">84292</span>, Aug <span class="number">18</span> <span class="number">2016</span>, <span class="number">15</span>:<span class="number">13</span>:<span class="number">37</span>) </span><br><span class="line">[<span class="meta">GCC 4.4.7 20120313 (Red Hat 4.4.7-17)</span>] <span class="keyword">on</span> linux2</span><br><span class="line">Type <span class="string">&quot;help&quot;</span>, <span class="string">&quot;copyright&quot;</span>, <span class="string">&quot;credits&quot;</span> <span class="keyword">or</span> <span class="string">&quot;license&quot;</span> <span class="keyword">for</span> more information.</span><br></pre></td></tr></table></figure>
<p>输入Python命令，查看可以得知是Python2.6.6版本</p>
<p>输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">which</span> python</span><br></pre></td></tr></table></figure>
<p>可以查看位置，一般是位于/usr/bin/python目录下。</p>
<p>下面介绍安装Python3的方法</p>
<p>首先安装依赖包</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">yum</span> -y groupinstall <span class="string">&quot;Development tools&quot;</span></span><br><span class="line"><span class="attribute">yum</span> -y install zlib-devel bzip<span class="number">2</span>-devel openssl-devel ncurses-devel sqlite-devel readline-devel tk-devel gdbm-devel db<span class="number">4</span>-devel libpcap-devel xz-devel</span><br></pre></td></tr></table></figure>
<p>然后根据自己需求下载不同版本的Python3，我下载的是Python3.7.4</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">https</span>://www.python.org/ftp/python/<span class="number">3</span>.<span class="number">7</span>,<span class="number">4</span>/Python-<span class="number">3</span>.<span class="number">7</span>.<span class="number">4</span>.tar.xz</span><br></pre></td></tr></table></figure>
<p>如果速度不够快，可以直接去官网下载，利用WinSCP等软件传到服务器上指定位置，我的存放目录是/usr/local/python3，使用命令：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">mkdir <span class="regexp">/usr/</span>local/python3 </span><br></pre></td></tr></table></figure>
<p>建立一个空文件夹</p>
<p>然后解压压缩包，进入该目录，安装Python3</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">tar -xvJf  Python-<span class="number">3.7</span>.<span class="number">4</span>.tar.xz</span><br><span class="line">cd Python-<span class="number">3.7</span>.<span class="number">4</span></span><br><span class="line">.<span class="regexp">/configure --prefix=/u</span>sr<span class="regexp">/local/</span>python3</span><br><span class="line">make &amp;&amp; make install</span><br></pre></td></tr></table></figure>
<p>最后创建软链接</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">ln -s <span class="regexp">/usr/</span>local<span class="regexp">/python3/</span>bin<span class="regexp">/python3 /u</span>sr<span class="regexp">/bin/</span>python3</span><br><span class="line">ln -s <span class="regexp">/usr/</span>local<span class="regexp">/python3/</span>bin<span class="regexp">/pip3 /u</span>sr<span class="regexp">/bin/</span>pip3</span><br></pre></td></tr></table></figure>
<p>在命令行中输入python3测试</p>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><ul>
<li><p>依赖包查找失败</p>
<p>编译make的时候会出现：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Python build finished successfully!</span><br><span class="line">The necessary bits to build these optional modules were not found:</span><br><span class="line">_curses               _curses_panel         _lzma</span><br><span class="line">_tkinter              _uuid                 readline</span><br><span class="line">To find the necessary bits, look in setup.py in detect_modules() for the module&#x27;s name.</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">The following modules found by detect_modules() in setup.py, have been</span><br><span class="line">built by the Makefile instead, as configured by the Setup files:</span><br><span class="line">_abc                  atexit                pwd</span><br><span class="line">time</span><br></pre></td></tr></table></figure>
<p>这种情况下安装python命令可以正常执行，但是有些任务会import 报错，安装superset时就除了问题</p>
<p><strong>解决：</strong></p>
<ul>
<li><p>_sqlite: </p>
<p><span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTIxMDY2NC9uby1tb2R1bGUtbmFtZWQtc3FsaXRlMw==">https://stackoverflow.com/questions/1210664/no-module-named-sqlite3<i class="fa fa-external-link-alt"></i></span></p>
<p><code>yum install sqlite-devel</code></p>
<p>然后重新编译安装python3</p>
</li>
<li><p>_lzma:</p>
<p><span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL3VsdHJhbHl0aWNzL3lvbG92NS9pc3N1ZXMvMTI5OA==">https://github.com/ultralytics/yolov5/issues/1298<i class="fa fa-external-link-alt"></i></span></p>
</li>
</ul>
</li>
</ul>
<p>参考：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2EyMDk5OTQ4NzY4L2FydGljbGUvZGV0YWlscy84MTUzMTc3NA==">https://blog.csdn.net/a2099948768/article/details/81531774<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title>Flink从入门到放弃01——Flink简介</title>
    <url>/2021/12/08/Flink%E4%BB%8E%E5%85%A5%E9%97%A8%E5%88%B0%E6%94%BE%E5%BC%8301%E2%80%94%E2%80%94Flink%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<p>Apache Flink是一个面向数据流处理和批量数据处理的可分布式的开源计算框架，它基于同一个Flink流式执行模型（streaming execution model），能够支持流处理和批处理两种应用类型。由于流处理和批处理所提供的SLA(服务等级协议)是完全不相同， 流处理一般需要支持低延迟、Exactly-once保证，而批处理需要支持高吞吐、高效处理，所以在实现的时候通常是分别给出两套实现方法，或者通过一个独立的开源框架来实现其中每一种处理方案。</p>
<a id="more"></a>

<h1 id="Flink是什么"><a href="#Flink是什么" class="headerlink" title="Flink是什么"></a>Flink是什么</h1><p>Apache flink前身是柏林理工大学一个研究性项目， 在 2014 被 Apache 孵化器接收，然后迅速地成为了Apache Software Foundation的顶级项目之一。</p>
<blockquote>
<p>Apache Flink is a framework and <em><strong>distributed</strong></em> processing engine for <em><strong>stateful</strong></em> computations over <em><strong>unbounded and bounded</strong></em> data <em><strong>streams</strong></em>.</p>
</blockquote>
<h1 id="为什么选择Flink"><a href="#为什么选择Flink" class="headerlink" title="为什么选择Flink"></a>为什么选择Flink</h1><h2 id="传统数据处理架构"><a href="#传统数据处理架构" class="headerlink" title="传统数据处理架构"></a>传统数据处理架构</h2><p>大多数企业实施的传统架构区分了两种类型的数据处理模式：数据事务处理和数据分析处理。两种架构分别面向不同的功能需求，适用于不同场景，具有各自的优势和局限</p>
<h3 id="事务处理架构"><a href="#事务处理架构" class="headerlink" title="事务处理架构"></a>事务处理架构</h3><p>事务处理架构中，各种应用程序分别由单独的层编写，如用户关系关系CRM、订单系统、web应用。应用程序通常连接到外部服务或直接面向用户，并持续处理传入的事件，如网站上的订单，电子邮件或点击。处理事件时，<strong>应用程序将会读取远程数据库的状态，或者通过运行事务来更新它</strong>。通常，一个数据库系统被多个应用程序共用。</p>
<p>这种架构的优势是，对于用户产生的事件可以进行快速的响应，事件来一个处理一个，<strong>低时延</strong>，但是由于后台共用一个远程数据库，<strong>当数据越来越庞大的时候代价会很高，并且扩展性不好</strong>。应用程序可以通过分布式处理来解决，但是对于需要综合数据实现分析类功能时，关系型数据库的联表查询会出问题。</p>
<img data-src="/images/Flink%E4%BB%8E0%E5%88%B01%EF%BC%9A01-Flink%E7%AE%80%E4%BB%8B/spaf_0101.png" alt="img" style="zoom:50%;" />

<h3 id="分析处理架构"><a href="#分析处理架构" class="headerlink" title="分析处理架构"></a>分析处理架构</h3><p>事务数据通常分布在多个数据库中，往往汇总起来联合分析时更有价值。所以我们一般不会直接在事务数据库上运行分析查询，而是复制数据到数据仓库。数据仓库是对工作负载进行分析和查询的专用数据存储。为了填充数据仓库，需要将事务数据库系统管理的数据复制过来。<strong>将数据复制到数据仓库的过程称为extract-transform-load（ETL）</strong>。 ETL过程从事务数据库中提取数据，将其转换为某种通用的结构表示，可能包括验证，值的规范化，编码，重复数据删除（去重）和模式转换，最后将其加载到分析数据库中。 ETL过程可能非常复杂，并且通常需要技术复杂的解决方案来满足性能要求。 ETL过程需要定期运行以保持数据仓库中的数据同步。</p>
<p>数据仓库上的查询类型有两种：<strong>第一种类型是定期报告查询</strong>，用于计算与业务相关的统计信息。<strong>第二种类型是即席查询</strong>，旨在提供特定问题的答案并支持关键业务决策。两种查询由批处理方式由数据仓库执行。</p>
<p>这种架构的问题很明显，<strong>实时性较差</strong>，不适用于延迟要求低的事务处理要求。</p>
<img data-src="https://confucianzuoyuan.github.io/flink-tutorial/book/images/spaf_0103.png" alt="img" style="zoom: 50%;" />

<h2 id="流处理架构"><a href="#流处理架构" class="headerlink" title="流处理架构"></a>流处理架构</h2><p>流处理的目标就是模拟真实情况下的数据特点，同时满足低延迟、高吞吐的数据处理要求。</p>
<h3 id="有状态的流处理"><a href="#有状态的流处理" class="headerlink" title="有状态的流处理"></a>有状态的流处理</h3><p>有状态的流处理方式将数据的中间状态直接存储在内存当中，处理过程中，不需要进行反复写入和更新远程数据库，而直接基于内存存储状态完成计算。由于保存在内存中的状态（local state）容易丢失，可以依靠定期将应用程序状态的一致性检查点（check point）写入远程且持久的存储。因此同时具备<strong>高吞吐、低延迟、可靠</strong>的特定。</p>
<img data-src="https://confucianzuoyuan.github.io/flink-tutorial/book/images/spaf_0104.png" alt="img" style="zoom:50%;" />

<h3 id="lambda架构"><a href="#lambda架构" class="headerlink" title="lambda架构"></a>lambda架构</h3><p>基于有状态流处理方案设计的第一代分布式开源流处理器（2011），专注于具有毫秒延迟的事件处理，并提供了在发生故障时防止事件丢失的保证。这些系统具有相当低级的API，并且对于流应用程序的准确性和结果的一致性，不提供内置支持，因为结果会取决于到达事件的时间和顺序。另外，即使事件没有丢失，也可能不止一次地处理它们。<strong>与批处理器相比，第一代开源流处理器牺牲了结果准确性，用来获得更低的延迟</strong>。为了让当时的数据处理系统，可以同时提供快速和准确的结果，设计了lambda架构。</p>
<img data-src="https://confucianzuoyuan.github.io/flink-tutorial/book/images/spaf_0107.png" alt="img" style="zoom:50%;" />

<p>批处理器定期处理批量存储中的数据，将准确的结果写入批处理表，并从速度表中删除相应的不准确结果。应用程序会合并快速表中的近似结果和批处理表中的准确结果，然后消费最终的结果。</p>
<p>这种架构的问题在于，每个功能都需要实现两个独立的、具有不同API的处理系统，难以建立和维护。</p>
<h2 id="flink架构特点"><a href="#flink架构特点" class="headerlink" title="flink架构特点"></a>flink架构特点</h2><h3 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h3><ul>
<li><p>事件驱动 Event-drive</p>
<p><strong>事件驱动的应用程序</strong>是有状态的应用程序，它从一个或多个事件中提取事件，并通过触发计算，状态更新或外部操作来对传入的事件做出反应。</p>
<img data-src="/images/Flink%E4%BB%8E0%E5%88%B01%EF%BC%9A01-Flink%E7%AE%80%E4%BB%8B/image-20211208142135187.png" alt="image-20211208142135187" style="zoom: 67%;" /></li>
<li><p>基于流的世界观</p>
<p>一切都是由流组成的，<strong>离线数据是有界的流;实时数据是一个没有界限的流</strong></p>
</li>
<li><p>分层API</p>
<ul>
<li>越顶层越抽象，表达含义越简明，使用越方便</li>
<li>越底层越具体，表达能力越丰富，使用越灵活</li>
</ul>
<img data-src="/images/Flink%E4%BB%8E0%E5%88%B01%EF%BC%9A01-Flink%E7%AE%80%E4%BB%8B/image-20211208142557976.png" alt="image-20211208142557976" style="zoom:50%;" /></li>
</ul>
<h3 id="其他特点"><a href="#其他特点" class="headerlink" title="其他特点"></a>其他特点</h3><ul>
<li><p>支持事件时间（event-time）和处理时间(processing-time)语义</p>
<ul>
<li><p><strong><code>Processing Time</code>(处理时间)是指执行相应操作的机器系统时间</strong>，是操作算子在计算过程中获取到的所在主机的系统时间。当用户选择使用处理时间时，所有和时间相关的算子，例如 Windows 计算，在当前任务中所有的算子直接使用所在主机的系统时间。例如，一个基于处理时间按每小时进行处理的时间窗口将处理一个小时内（以系统时间为标准）到达指定算子的所有的记录。</p>
<p>处理时间是最简单的一个时间概念，不需要在数据流和机器之间进行协调。具有最好的性能和最低的延迟。然而，在分布式或者异步环境中，处理时间具有不确定性，因为容易受到记录到达系统速度的影响(例如，从消息队列到达的记录)，还会受到系统内记录在不同算子之间的流动速度的影响。对数据乱序的处理，处理时间不是一种最优的选择。总之，<strong>处理时间适用于时间计算精度要求不是特别高的计算场景</strong>。</p>
</li>
<li><p>**<code>Event Time</code>(事件时间)是每个事件在产生它的设备上发生的时间。****在进入 Flink 之前，事件时间通常要嵌入到记录中，并且事件时间也可以从记录中提取出来。对于事件时间，时间的进度取决于数据，而不是系统时钟。基于事件时间的程序必须指定如何生成事件时间的<code>Watermarks</code>，这是表示事件时间进度的机制。</p>
<p>在理想情况下，事件时间处理将产生完全一致且确定的结果，无论事件何时到达以及以什么样的顺序到达。但是，除非已知事件是按顺序（按时间戳）到达，否则事件时间处理在等待无序事件时产生一定的延迟。由于只能等待有限的时间，因此这限制了事件时间应用程序的确定性。</p>
<p>假定所有数据都已到达，事件时间算子将按预期方式运行，即使在处理无序、迟到事件或重新处理历史数据时，也会产生正确且一致的结果。例如，每小时事件时间窗口将将处理事件时间在这一小时之内所有的记录，不管它们何时到达，以及它们以什么顺序到达。</p>
<p><strong>按事件时间处理往往会导致一定的延迟，因为它要等待延迟事件和无序事件一段时间。因此，事件时间程序通常与处理时间操作相结合使用。</strong></p>
</li>
</ul>
</li>
<li><p>精确一次(exactly-once)的状态一致性保证</p>
<ul>
<li><strong>状态</strong>：为了产生一个结果，函数一般会聚合某个时间段内（或是一定数量的）events的状态信息（例如计算聚合值，或是发现一个模式），有状态的 operators使用流的输入事件以及内部状态，计算出它们的输出。<strong>例如，一个滚动聚合operator输出当前它读入的所有的events的总和。Operator 持有当前sum的值作为它的内部状态，并在每次读入新值时对它做更新。</strong></li>
<li><strong>exactly-once</strong>：流处理系统通过提供结果保障（result guarantees）定义任务在故障发生时的行为。主流流处理器提供的保障（guarantees）包括<strong>至多一次at-most-once、至少一次（AT-LEAST-ONCE）、精确一次（EXACTLY-ONCE）</strong>等。exactly-once是最严个保障。</li>
</ul>
</li>
<li><p>低延迟，每秒处理数百万个事件，毫秒级延迟</p>
</li>
<li><p>与众多常用存储系统的连接</p>
</li>
<li><p>高可用，动态扩展，实现7*24小时全天候运行</p>
</li>
</ul>
<h3 id="Flink-amp-Spark-streaming"><a href="#Flink-amp-Spark-streaming" class="headerlink" title="Flink &amp; Spark streaming"></a>Flink &amp; Spark streaming</h3><ul>
<li>spark streaming 本质是微批处理，flink是真正的流处理平台</li>
<li>spark采用RDD(弹性分布式算子)，flink基本数据模型是数据流</li>
<li>spark是批计算，将DAG划分成不同的stage，（一个单位的）所有数据完成一个stage才能开始下一个，有一定的延迟；flink一个事件在一个节点处理完成后可以直接发往下一个</li>
</ul>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p>传统架构演进 <span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbm51b2dlNDc2Ni9hcnRpY2xlL2RldGFpbHMvOTQ0ODQyNjM=">https://blog.csdn.net/wannuoge4766/article/details/94484263<i class="fa fa-external-link-alt"></i></span><br>教程视频 <span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMXF5NHkxcTcyOD9wPTQ=">https://www.bilibili.com/video/BV1qy4y1q728?p=4<i class="fa fa-external-link-alt"></i></span><br>flink教程文档 <span class="exturl" data-url="aHR0cHM6Ly9jb25mdWNpYW56dW95dWFuLmdpdGh1Yi5pby9mbGluay10dXRvcmlhbC9ib29rLw==">https://confucianzuoyuan.github.io/flink-tutorial/book/<i class="fa fa-external-link-alt"></i></span><br>时间时间 <span class="exturl" data-url="aHR0cDovL3NtYXJ0c2kuY2x1Yi9mbGluay1zdHJlYW0tZXZlbnQtdGltZS1hbmQtcHJvY2Vzc2luZy10aW1lLmh0bWw=">http://smartsi.club/flink-stream-event-time-and-processing-time.html<i class="fa fa-external-link-alt"></i></span><br>状态一致 <span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vemFja3N0YW5nL3AvMTA4NTAwMjMuaHRtbA==">https://www.cnblogs.com/zackstang/p/10850023.html<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>BigData</category>
      </categories>
      <tags>
        <tag>Flink</tag>
      </tags>
  </entry>
  <entry>
    <title>VMware三种联网方式及原理</title>
    <url>/2021/07/03/Vmware%E4%B8%89%E7%A7%8D%E8%81%94%E7%BD%91%E6%96%B9%E5%BC%8F%E5%8F%8A%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>虚拟机技术在最近的几年中得到了广泛的发展，一些大型网络服务商都开始采用虚拟机技术，不仅节省了投资成本，更节约了能源的消耗。我们知道VMware也分几种版本，普通用户最常用的就是Workstation，但是不管使用哪种版本，我们都能发现在安装过程中让我们选择网络模式。在默认情况下会选中桥接模式，但有用户会问其他模式是干什么用的？有时候选择了其他模式之后就不能上网了。学习spark的standalone模式时，需要基于虚拟机进行模拟集群搭建。所以详细记录相关操作经验及原理备忘。</p>
<a id="more"></a>

<h2 id="1-VMware三种联网方式及原理"><a href="#1-VMware三种联网方式及原理" class="headerlink" title="1. VMware三种联网方式及原理"></a>1. VMware三种联网方式及原理</h2><p>vmware提供三种虚拟机联网方法：bridge桥接模式，NAT网络地址转换模式，Host-only仅主机模式。</p>
<ul>
<li><p>桥接模式</p>
<blockquote>
<p><strong>首先理解“桥接”的概念。</strong></p>
<p>路由器上一般有多个LAN口，不同LAN口之间就是桥接关系。这个路由器就是“桥”。一个桥设备上有多块网卡，分别处于多个局域网中。桥设备的作用就是学习不同网口连接的mac地址，并在转发帧的时候查询mac地址和LAN口的绑定关系。</p>
</blockquote>
<p>VMware的桥也是一样的道理，采用桥接模式时，VMware会虚拟出一块网卡和真正的物理网卡进行桥接，这样发到物理网卡的所有数据包都到了VMware虚拟机，由虚拟机发出的数据包也会通过桥从物理网卡那端发出。VMware的虚拟机就像局域网中一台独立的主机，可以访问局域网内任意一台机器。</p>
</li>
<li><p>NAT模式</p>
<p>VMware的NAT是在主机和虚拟机之间用软件伪造出一块网卡，这块网卡和虚拟机的ip处于同一个地址段，同时和主机的网络接口之间进行NAT。虚拟机相当于一台内网设备，能够ping到主机IP。</p>
</li>
<li><p>HostOnly模式</p>
<p>HostOnly模式下，虚拟网络是一个全封闭的网络，唯一能访问的就是主机。</p>
</li>
</ul>
<h2 id="2-不同方式的设置及其他操作"><a href="#2-不同方式的设置及其他操作" class="headerlink" title="2. 不同方式的设置及其他操作"></a>2. 不同方式的设置及其他操作</h2><p>安装完虚拟机之后，会在控制面板-&gt; 网络和共享中心 -&gt; 更改适配器设置 中，新增两块虚拟网卡：</p>
<img data-src="/images/Vmware%E4%B8%89%E7%A7%8D%E8%81%94%E7%BD%91%E6%96%B9%E5%BC%8F%E5%8F%8A%E5%8E%9F%E7%90%86/image-20210703102545051.png" alt="image-20210703102545051" style="zoom:50%;" />

<p>VMware Network Adepter VMnet1：Host用于与Host-Only虚拟网络进行通信的虚拟网卡<br>VMware Network Adepter VMnet8：Host用于与NAT虚拟网络进行通信的虚拟网卡</p>
<h3 id="桥接模式设置"><a href="#桥接模式设置" class="headerlink" title="桥接模式设置"></a>桥接模式设置</h3><p>这种模式下，需要手工设置虚拟机的IP地址、子网掩码，必须保持和宿主机处于同一个网段，这样虚拟机才能和宿主机通信（我理解相当于通过设置为同一网段，使具备桥设备的桥接功能）</p>
<ul>
<li><p>首先确定主机ip设置，ipconfig</p>
<p><img data-src="/images/Vmware%E4%B8%89%E7%A7%8D%E8%81%94%E7%BD%91%E6%96%B9%E5%BC%8F%E5%8F%8A%E5%8E%9F%E7%90%86/image-20210703110322533.png" alt="image-20210703110322533"></p>
<p>将自动获取IP地址修改为指定ip</p>
<p><img data-src="/images/Vmware%E4%B8%89%E7%A7%8D%E8%81%94%E7%BD%91%E6%96%B9%E5%BC%8F%E5%8F%8A%E5%8E%9F%E7%90%86/image-20210703110405014.png" alt="image-20210703110405014"></p>
</li>
<li><p>在VMware-&gt;edit-&gt;虚拟网络编辑器中修改设置VMnet</p>
<img data-src="/images/Vmware%E4%B8%89%E7%A7%8D%E8%81%94%E7%BD%91%E6%96%B9%E5%BC%8F%E5%8F%8A%E5%8E%9F%E7%90%86/20180415183840256" alt="img" style="zoom:50%;" />

<img data-src="/images/Vmware%E4%B8%89%E7%A7%8D%E8%81%94%E7%BD%91%E6%96%B9%E5%BC%8F%E5%8F%8A%E5%8E%9F%E7%90%86/20180415183903429" alt="img" style="zoom:50%;" />

<p>选择 桥接模式，然后点击 还原默认设置，然后再重新进来，不打开虚拟机，进入设置项，设置为桥接模式。</p>
<p><img data-src="/images/Vmware%E4%B8%89%E7%A7%8D%E8%81%94%E7%BD%91%E6%96%B9%E5%BC%8F%E5%8F%8A%E5%8E%9F%E7%90%86/20180415183958794" alt="img"></p>
<p>打开虚拟机，进入settings，然后设置ipv4网络</p>
<img data-src="/images/Vmware%E4%B8%89%E7%A7%8D%E8%81%94%E7%BD%91%E6%96%B9%E5%BC%8F%E5%8F%8A%E5%8E%9F%E7%90%86/image-20210703115033366.png" alt="image-20210703115033366" style="zoom:50%;" />

<p><img data-src="/images/Vmware%E4%B8%89%E7%A7%8D%E8%81%94%E7%BD%91%E6%96%B9%E5%BC%8F%E5%8F%8A%E5%8E%9F%E7%90%86/image-20210703213335139.png" alt="image-20210703213335139"></p>
<p>这里的192.168.124.7是和主机ip在统一网段的。重新开启网络就可以看到配置已经成功。</p>
<p><img data-src="/images/Vmware%E4%B8%89%E7%A7%8D%E8%81%94%E7%BD%91%E6%96%B9%E5%BC%8F%E5%8F%8A%E5%8E%9F%E7%90%86/image-20210703213435546.png" alt="image-20210703213435546"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title>nginx+Ngrok在mac下实现内网穿透</title>
    <url>/2021/01/09/nginx+Ngrok%E5%9C%A8mac%E4%B8%8B%E5%AE%9E%E7%8E%B0%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</url>
    <content><![CDATA[<p>使用maltego产品，用公司数据做关系探索演示。服务部署在内网环境中，和产品云服务平台交互需要实现内网穿透。简单了解下相关流程。</p>
<a id="more"></a>

<h1 id="Nginx介绍"><a href="#Nginx介绍" class="headerlink" title="Nginx介绍"></a>Nginx介绍</h1><h2 id="产生"><a href="#产生" class="headerlink" title="产生"></a>产生</h2><p>Nginx和Apache一样，都是一种<strong>web服务器软件</strong>。基于REST架构风格，以统一URI或URL作为沟通依据，通过HTTP协议提供各种网络服务。但<strong>Apche</strong>发展较早，虽然作为世界第一大服务器软件，具有<strong>稳定、开源、跨平台</strong>的优点，但是他被设计为一个<strong>重量级的不支持高并发的服务器</strong>。数以万计的并发访问会导致服务器消耗大量内存。操作系统对其进行进程或线程间的切换也消耗了大量的CPU资源，导致HTTP请求的平均响应速度降低。</p>
<p><strong>因此轻量级高并发的服务器Nginx应运而生。</strong></p>
<p>Nginx由俄罗斯工程师采用C语言开发，具有以下<strong>特点</strong>：</p>
<ol>
<li>Nginx使用基于<strong>事件驱动架构</strong>，使得其可以支持数以百万级别的TCP连接<br>（<span class="exturl" data-url="aHR0cHM6Ly9kZXZlbG9wZXIuaWJtLmNvbS96aC90ZWNobm9sb2dpZXMvbWVzc2FnaW5nL2FydGljbGVzL2FkdmFudGFnZXMtb2YtYW4tZXZlbnQtZHJpdmVuLWFyY2hpdGVjdHVyZS8=">事件驱动架构<i class="fa fa-external-link-alt"></i></span>：是指<strong>松散耦合</strong>的<strong>微服务系统</strong>）</li>
<li>高度的模块化和自由软件许可证使得第三方模块层出不穷</li>
<li>跨平台服务器，可以运行在Linux，Windows，FreeBSD，Solaris，AIX，Mac OS等操作系统上</li>
<li>极大的稳定性</li>
</ol>
<h1 id="Nginx-安装与配置"><a href="#Nginx-安装与配置" class="headerlink" title="Nginx 安装与配置"></a>Nginx 安装与配置</h1><ul>
<li><p>安装</p>
<p><code> yum install nginx</code></p>
</li>
<li><p>配置文件解读 <span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC83NDI1Njk0Ng==">https://zhuanlan.zhihu.com/p/74256946<i class="fa fa-external-link-alt"></i></span></p>
<ul>
<li>文件结构：</li>
</ul>
<figure class="highlight jboss-cli"><table><tr><td class="code"><pre><span class="line"><span class="string">...</span></span><br><span class="line">events &#123;</span><br><span class="line">        <span class="string">...</span></span><br><span class="line">&#125;</span><br><span class="line">http &#123;</span><br><span class="line">    <span class="string">...</span></span><br><span class="line">    server &#123;</span><br><span class="line">        <span class="string">....</span></span><br><span class="line">        location &#123;</span><br><span class="line">            root html;</span><br><span class="line">            <span class="string">...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>nginx配置指令分为<strong>指令块</strong>和<strong>单个指令</strong>（如root html）</p>
<ul>
<li>全局配置</li>
</ul>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">user nginx;</span><br><span class="line">worker_processes auto;</span><br><span class="line">error_log <span class="regexp">/var/</span>log<span class="regexp">/nginx/</span>error.log;</span><br><span class="line">pid <span class="regexp">/run/</span>nginx.pid;</span><br><span class="line"></span><br><span class="line"># Load dynamic modules. See <span class="regexp">/usr/</span>share<span class="regexp">/doc/</span>nginx/README.dynamic.</span><br><span class="line"><span class="keyword">include</span> <span class="regexp">/usr/</span>share<span class="regexp">/nginx/m</span>odules<span class="comment">/*.conf;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">events &#123;</span></span><br><span class="line"><span class="comment">    worker_connections 1024;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure>
<p><code>user</code>：指定nginx的工作进程的用户及用户组，默认是nobody用户<br><code>worker_processes</code>:指定工作进程的个数，默认是1个。具体可以根据服务器cpu数量进行设置，比如cpu有4个，可以设置为4。如果不知道cpu的数量，可以设置为auto。nginx会自动判断服务器的cpu个数，并设置相应的进程数。<br><code>error_log</code>:设置nginx的错误日志路径，并设置相应的输出级别。如果编译时没有指定编译调试模块，那么 info就是最详细的输出模式了。如果有编译debug模块，那么debug时最为详细的输出模式。这里设置为默认就好了。<br><code>pid</code>: 指定nginx进程pid的文件路径。<br><code>events </code> :这个指令块用来设置工作进程的工作模式以及每个进程的连接上限。<br>-<code>use</code> :用来指定nginx的工作模式，通常选择epoll，除了epoll，还有select,poll。<br>-<code>worker_connections</code>:定义每个工作进程的最大连接数，默认是1024。客户端最大连接数，就要考虑有几个工作进程了，两者相乘就是的。当nginx作反向代理时，需要除以2.</p>
</li>
<li><p>修改端口号和html目录</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">    <span class="attribute">listen</span>       <span class="number">128</span> default_server;</span><br><span class="line">    <span class="attribute">listen</span>       [::]:<span class="number">128</span> default_server;</span><br><span class="line">    <span class="attribute">server_name</span>  _;</span><br><span class="line">    <span class="comment"># root         /usr/share/nginx/html;</span></span><br><span class="line">    <span class="attribute">root</span>         /root/CyberNarrator/ShowCyberNarrator;</span><br><span class="line">  </span><br><span class="line">    <span class="comment"># Load configuration files for the default server block.</span></span><br><span class="line">    <span class="attribute">include</span> /etc/nginx/default.d/<span class="regexp">*.conf</span>;</span><br><span class="line">  </span><br><span class="line">    <span class="attribute">location</span> / &#123;</span><br><span class="line">        <span class="attribute">autoindex</span> <span class="literal">on</span>; <span class="comment"># 显示目录</span></span><br><span class="line">        <span class="attribute">autoindex_exact_size</span> <span class="literal">on</span>;</span><br><span class="line">        <span class="attribute">autoindex_localtime</span> <span class="literal">on</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="attribute">error_page</span> <span class="number">404</span> /<span class="number">404</span>.html;</span><br><span class="line">    <span class="attribute">location</span> = /<span class="number">404</span>.html &#123;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="attribute">error_page</span> <span class="number">500</span> <span class="number">502</span> <span class="number">503</span> <span class="number">504</span> /50x.html;</span><br><span class="line">    <span class="attribute">location</span> = /50x.html &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重启nginx服务<code>nginx service start</code> 后，访问192.168.40.154:128出现403 forbedden</p>
<p>原因：Web目录/root/CyberNarrator/ShowCyberNarrator权限问题，修改为777也没有解决。将web目录改为home下目录/home/cyber_narrator/show_maltego成功。</p>
<h2 id="基于Nginx在mac上搭建本地文件服务器"><a href="#基于Nginx在mac上搭建本地文件服务器" class="headerlink" title="基于Nginx在mac上搭建本地文件服务器"></a>基于Nginx在mac上搭建本地文件服务器</h2><p>在服务器上尝试成功后，实现在mac上搭建文件服务器</p>
</li>
<li><p><code>brew install nginx</code> 安装nginx，发现已经安装过，不知道啥时候安装的。</p>
</li>
<li><p>运行nginx <code>nginx</code> 提示端口被占用</p>
</li>
<li><p>查看端口 占用情况 <code>lsof -i: 8080</code></p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">COMMAND</span>   PID USER   FD   TYPE             DEVICE SIZE/<span class="literal">OFF</span> NODE NAME</span><br><span class="line"><span class="attribute">nginx</span>   <span class="number">40125</span>  joy    <span class="number">6</span>u  IPv<span class="number">4</span> <span class="number">0</span>xd<span class="number">9490</span>f<span class="number">7</span>db<span class="number">5</span>cbf<span class="number">449</span>      <span class="number">0</span>t<span class="number">0</span>  TCP *:http-alt (LISTEN)</span><br><span class="line"><span class="attribute">nginx</span>   <span class="number">40126</span>  joy    <span class="number">6</span>u  IPv<span class="number">4</span> <span class="number">0</span>xd<span class="number">9490</span>f<span class="number">7</span>db<span class="number">5</span>cbf<span class="number">449</span>      <span class="number">0</span>t<span class="number">0</span>  TCP *:http-alt (LISTEN)</span><br></pre></td></tr></table></figure></li>
<li><p>如果需要杀掉进程，输入 <code>kill -9 pid </code> 或 <code>kill-9 name</code></p>
</li>
<li><p>修改nginx.conf</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><span class="line"><span class="section">server</span> &#123;</span><br><span class="line">     <span class="attribute">listen</span>       <span class="number">8080</span>;</span><br><span class="line">     <span class="attribute">server_name</span>  localhost;</span><br><span class="line">     <span class="attribute">root</span> /Users/joy/work/iie/project/cyber_narrator/MALTEGO/html;</span><br><span class="line">     <span class="attribute">location</span> / &#123;</span><br><span class="line">         <span class="attribute">autoindex</span> <span class="literal">on</span>; </span><br><span class="line">         <span class="attribute">autoindex_exact_size</span> <span class="literal">on</span>;</span><br><span class="line">         <span class="attribute">autoindex_localtime</span> <span class="literal">on</span>;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure></li>
<li><p>保存配置文件，<code>nginx</code> 运行，<code>nginx -s reload</code> 重新加载配置文件</p>
</li>
<li><p>访问 <span class="exturl" data-url="aHR0cDovL2xvY2FsaG9zdDo4MDgwL3RyYW5zZm9ybXMv">http://localhost:8080/transforms/<i class="fa fa-external-link-alt"></i></span> 即出现web root目录下transform文件夹的文件。</p>
</li>
</ul>
<h2 id="Ngrok实现内网穿透"><a href="#Ngrok实现内网穿透" class="headerlink" title="Ngrok实现内网穿透"></a>Ngrok实现内网穿透</h2><p><span class="exturl" data-url="aHR0cHM6Ly9sZWFybmt1LmNvbS9hcnRpY2xlcy8zNjEyOQ==">Ngrok<i class="fa fa-external-link-alt"></i></span>是一个<strong>反向代理</strong>，内网穿透工具</p>
<ul>
<li><p>注册账号 </p>
</li>
<li><p>下载安装包</p>
</li>
<li><p><span class="exturl" data-url="aHR0cHM6Ly9kYXNoYm9hcmQubmdyb2suY29tL2dldC1zdGFydGVkL3NldHVw">配置authtoken<i class="fa fa-external-link-alt"></i></span></p>
<p><code>./ngrok authtoken 1muCRyfXzexS8Ui5RWIi4pvUNvR_2rGsMdvDwQpKcwS1iTpAo</code></p>
</li>
<li><p>运行命令</p>
<p>ngrok http -host-header=shop.test -region us 8080</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">Session</span> Status                online                                                                                  </span><br><span class="line"><span class="attribute">Account</span>                       yinjiangyi (Plan: Free)                                                                 </span><br><span class="line"><span class="attribute">Version</span>                       <span class="number">2</span>.<span class="number">3</span>.<span class="number">35</span>                                                                                  </span><br><span class="line"><span class="attribute">Region</span>                        United States (us)                                                                      </span><br><span class="line"><span class="attribute">Web</span> Interface                 http://<span class="number">127.0.0.1:4040</span>                                                                   </span><br><span class="line"><span class="attribute">Forwarding</span>                    http://<span class="number">08112</span>e<span class="number">20</span>c<span class="number">814</span>.ngrok.io -&gt; http://localhost:<span class="number">8080</span>                                   </span><br><span class="line"><span class="attribute">Forwarding</span>                    https://<span class="number">08112</span>e<span class="number">20</span>c<span class="number">814</span>.ngrok.io -&gt; http://localhost:<span class="number">8080</span>                                  </span><br><span class="line">                                                                                                                      </span><br><span class="line"><span class="attribute">Connections</span>                   ttl     opn     rt<span class="number">1</span>     rt<span class="number">5</span>     p<span class="number">50</span>     p<span class="number">90</span>                                             </span><br><span class="line">                              <span class="attribute">3</span>       <span class="number">0</span>       <span class="number">0</span>.<span class="number">00</span>    <span class="number">0</span>.<span class="number">00</span>    <span class="number">0</span>.<span class="number">00</span>    <span class="number">0</span>.<span class="number">01</span>  </span><br></pre></td></tr></table></figure>
<p>这里forwarding表示分配的域名，<strong>免费账号每次分配的域名无法固定，关闭后再次运行代理服务后域名改变</strong>。配置完成后，就可以实现外网访问服务。</p>
</li>
</ul>
<hr>
<p>以下记录我在服务器上做了什么，以防后续产生问题有迹可循：：</p>
<ul>
<li>安装nginx，搭建文件服务器，web目录为/home/cyber_narrator/show_maltego</li>
<li>添加python3环境，<ul>
<li>home目录下新建yjy目录</li>
<li>安装目录/usr/local/python3  <strong>没有动现有的python2环境</strong></li>
</ul>
</li>
</ul>
<p>参考：<br><span class="exturl" data-url="aHR0cHM6Ly93d3cuY25ibG9ncy5jb20vd2N3bmluYS9wLzg3MjgzOTEuaHRtbA==">https://www.cnblogs.com/wcwnina/p/8728391.html<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>web服务</tag>
      </tags>
  </entry>
  <entry>
    <title>Mac下hadoop部署与操作</title>
    <url>/2021/03/30/Mac%E4%B8%8Bhadoop%E9%83%A8%E7%BD%B2%E4%B8%8E%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>由于课程需要和工具限制，需要在mac上安装Hadoop，参考了网上的教程，默认mac的terminal已经安装了homebrew软件管理工具、JDK环境，如果没安装homebrew、JDK环境的小伙伴请自行搜索mac终端安装homebrew、JDK教程。下面是部署与操作记录。</p>
<a id="more"></a>

<p>部署：</p>
<p><span class="exturl" data-url="aHR0cDovL2NvZGluZ3hpYXh3LmNuLzIwMTYvMTIvMDYvNTktbWFjLWhhZG9vcC8=">http://codingxiaxw.cn/2016/12/06/59-mac-hadoop/<i class="fa fa-external-link-alt"></i></span></p>
<p>其他问题：</p>
<p>1） hadoop下载速度太慢，切换国内镜像无效。<br>采用手动下载方式 <span class="exturl" data-url="aHR0cHM6Ly96aHVhbmxhbi56aGlodS5jb20vcC8xMDc0NjkzNzg=">https://zhuanlan.zhihu.com/p/107469378<i class="fa fa-external-link-alt"></i></span></p>
<p>2） 启动hadoop权限问题：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(base) MacBook-Pro:sbin joy$ ./start-dfs.sh </span><br><span class="line">Starting namenodes on [localhost]</span><br><span class="line">localhost: joy@localhost: Permission denied (publickey,password,keyboard-interactive).</span><br><span class="line">Starting datanodes</span><br><span class="line">localhost: joy@localhost: Permission denied (publickey,password,keyboard-interactive).</span><br><span class="line">Starting secondary namenodes [account.jetbrains.com]</span><br><span class="line">account.jetbrains.com: Warning: Permanently added &#x27;account.jetbrains.com,0.0.0.0&#x27; (ECDSA) to the list of known hosts.</span><br><span class="line">account.jetbrains.com: joy@account.jetbrains.com: Permission denied (publickey,password,keyboard-interactive).</span><br><span class="line">2021-03-30 18:38:31,682 WARN util.NativeCodeLoader: Unable to load native-hadoop library for your platform... using builtin-java classes where applicable</span><br></pre></td></tr></table></figure>
<p><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3poYW5ndmFsdWUvYXJ0aWNsZS9kZXRhaWxzLzEwMzc0ODQzOA==">https://blog.csdn.net/zhangvalue/article/details/103748438<i class="fa fa-external-link-alt"></i></span></p>
<p>3）按照<span class="exturl" data-url="aHR0cDovL2NvZGluZ3hpYXh3LmNuLzIwMTYvMTIvMDcvNjAtbWFjLXNwYXJrLyVFNSU4NiU4NSVFNSVBRSVCOSVFOCVCRiU5QiVFOCVBMSU4Q3NwYXJrJUU1JUFFJTg5JUU4JUEzJTg1JUU2JTk3JUI2JUVGJUJDJThDJUU3JTk0JUIxJUU0JUJBJThFJUU0JUI4JThCJUU4JUJEJUJEJUU5JTgwJTlGJUU1JUJBJUE2JUU5JTk3JUFFJUU5JUEyJTk4JUVGJUJDJThDJUU2JTg5JThCJUU1JThBJUE4JUU0JUI4JThCJUU4JUJEJUJEJUU1JUFFJTg5JUU4JUEzJTg1JUU1JThDJTg1JUU4JUJGJTlCJUU4JUExJThDJUU1JUFFJTg5JUU4JUEzJTg1JUVGJUJDJThDJUU1JThGJTkxJUU3JThFJUIwc2NhbGElRTQlQkQlQkYlRTclOTQlQTglRTYlQUQlQTMlRTUlQjglQjglRUYlQkMlOENzcGFyayVFNSU5MSVCRCVFNCVCQiVBNCVFNiU5NyVBMCVFNiVCMyU5NSVFNiVBRCVBMyVFNSVCOCVCOCVFOCVCRiU5MCVFOCVBMSU4QyVFRiVCQyU5QQ==">http://codingxiaxw.cn/2016/12/07/60-mac-spark/内容进行spark安装时，由于下载速度问题，手动下载安装包进行安装，发现scala使用正常，spark命令无法正常运行：<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">MacBook-Pro:conf joy$ scala</span><br><span class="line">Welcome to Scala 2.13.5 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_271).</span><br><span class="line">Type in expressions for evaluation. Or try :help.</span><br><span class="line"></span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> </span></span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(base) MacBook-Pro:conf joy$ spark-shell</span><br><span class="line">-bash: spark-shell: command not found</span><br></pre></td></tr></table></figure>
<p><strong>问题排查：主要原因在于scala下载后用homebrew安装，spark没有经过brew安装，建立软连接</strong></p>
<p>homebrew进行Scala安装时，手动下载安装包之后，按照2）解决方案进行后续安装操作，brew将scala自动安装在/usr/local/Cellar下，然后自动建立软连接到/usr/local/bin/目录下（安装时使用-v命令可查看详细过程）</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(base) MacBook-Pro:~ joy$ brew reinstall scala -v</span><br><span class="line">rm /usr/local/bin/fsc</span><br><span class="line">rm /usr/local/bin/scala</span><br><span class="line">rm /usr/local/bin/scalac</span><br><span class="line">rm /usr/local/bin/scaladoc</span><br><span class="line">rm /usr/local/bin/scalap</span><br><span class="line">rm /usr/local/share/doc/scala</span><br><span class="line">rm /usr/local/share/man/man1/fsc.1</span><br><span class="line">rm /usr/local/share/man/man1/scala.1</span><br><span class="line">rm /usr/local/share/man/man1/scalac.1</span><br><span class="line">rm /usr/local/share/man/man1/scaladoc.1</span><br><span class="line">rm /usr/local/share/man/man1/scalap.1</span><br><span class="line">==&gt; Downloading https://downloads.lightbend.com/scala/2.13.5/scala-2.13.5.tgz</span><br><span class="line">/usr/bin/curl --disable --globoff --show-error --user-agent Homebrew/3.0.10-42-ge5bda4e\ \(Macintosh\;\ Intel\ Mac\ OS\ X\ 10.15.7\)\ curl/7.64.1 --header Accept-Language:\ en --retry 3 --location --silent --head --request GET https://downloads.lightbend.com/scala/2.13.5/scala-2.13.5.tgz</span><br><span class="line">Already downloaded: /Users/joy/Library/Caches/Homebrew/downloads/f0d485510e9c8d56e9ed6b020888e122c1ef09fff596c0c93ca946952b4624c2--scala-2.13.5.tgz</span><br><span class="line">==&gt; Verifying checksum for &#x27;f0d485510e9c8d56e9ed6b020888e122c1ef09fff596c0c93ca946952b4624c2--scala-2.13.5.tgz&#x27;</span><br><span class="line">==&gt; Reinstalling scala </span><br><span class="line">/usr/bin/sandbox-exec -f /private/tmp/homebrew20210331-48919-1kaua9k.sb nice ruby -W1 -- /usr/local/Homebrew/Library/Homebrew/build.rb /usr/local/Homebrew/Library/Taps/homebrew/homebrew-core/Formula/scala.rb --verbose</span><br><span class="line">tar xof /Users/joy/Library/Caches/Homebrew/downloads/f0d485510e9c8d56e9ed6b020888e122c1ef09fff596c0c93ca946952b4624c2--scala-2.13.5.tgz -C /private/tmp/d20210331-48920-5yc016</span><br><span class="line">cp -pR /private/tmp/d20210331-48920-5yc016/scala-2.13.5/. /private/tmp/scala-20210331-48920-3r6y9a/scala-2.13.5</span><br><span class="line">chmod -Rf +w /private/tmp/d20210331-48920-5yc016</span><br><span class="line">==&gt; Cleaning</span><br><span class="line">==&gt; Finishing up</span><br><span class="line">ln -s ../Cellar/scala/2.13.5/bin/fsc fsc</span><br><span class="line">ln -s ../Cellar/scala/2.13.5/bin/scala scala</span><br><span class="line">ln -s ../Cellar/scala/2.13.5/bin/scalac scalac</span><br><span class="line">ln -s ../Cellar/scala/2.13.5/bin/scaladoc scaladoc</span><br><span class="line">ln -s ../Cellar/scala/2.13.5/bin/scalap scalap</span><br><span class="line">ln -s ../../Cellar/scala/2.13.5/share/doc/scala scala</span><br><span class="line">ln -s ../../../Cellar/scala/2.13.5/share/man/man1/fsc.1 fsc.1</span><br><span class="line">ln -s ../../../Cellar/scala/2.13.5/share/man/man1/scala.1 scala.1</span><br><span class="line">ln -s ../../../Cellar/scala/2.13.5/share/man/man1/scalac.1 scalac.1</span><br><span class="line">ln -s ../../../Cellar/scala/2.13.5/share/man/man1/scaladoc.1 scaladoc.1</span><br><span class="line">ln -s ../../../Cellar/scala/2.13.5/share/man/man1/scalap.1 scalap.1</span><br><span class="line">/usr/bin/sandbox-exec -f /private/tmp/homebrew20210331-48976-3t2vk6.sb nice ruby -W1 -I $LOAD_PATH -- /usr/local/Homebrew/Library/Homebrew/postinstall.rb /usr/local/Homebrew/Library/Taps/homebrew/homebrew-core/Formula/scala.rb</span><br><span class="line">==&gt; Caveats</span><br><span class="line">To use with IntelliJ, set the Scala home to:</span><br><span class="line">  /usr/local/opt/scala/idea</span><br><span class="line">==&gt; Summary</span><br><span class="line">🍺  /usr/local/Cellar/scala/2.13.5: 43 files, 23.4MB, built in 14 seconds</span><br></pre></td></tr></table></figure>
<p>而homebrew无法下载正确版本的spark，因此手动下载后，安装博客步骤进行安装，手动解压安装在/usr/loacal，配置时无脑copy</p>
<img data-src="/images/Mac%E4%B8%8Bhadoop%E9%83%A8%E7%BD%B2%E4%B8%8E%E6%93%8D%E4%BD%9C/image-20210331150851400.png" alt="image-20210331150851400" style="zoom:80%;" />

<p>其中scala_home路径应该为实际路径：brew自动安装后建立软连接的 <code>/usr/local/scala/bin</code> 而不是 <code>/usr/local/scala</code>。</p>
<p><strong>解决一：</strong>保持sparka安装在/usr/local目录下，修改conf中的scala home路径</p>
<p>上图修改为如下后，重新运行spark-shell命令成功。</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line"><span class="builtin-name">export</span> <span class="attribute">SCALA_HOME</span>=/usr/local/bin/scala</span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">SPARK_MASTER_IP</span>=localhost</span><br><span class="line"><span class="builtin-name">export</span> <span class="attribute">SPARK_WORKER_MEMORY</span>=4g</span><br></pre></td></tr></table></figure>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">MacBook-Pro:conf joy$ spark-shell</span><br><span class="line">21/03/31 15:00:37 WARN NativeCodeLoader: Unable to load native-hadoop library for your platform... using builtin-java classes where applicable</span><br><span class="line">Using Spark&#x27;s default log4j profile: org/apache/spark/log4j-defaults.properties</span><br><span class="line">Setting default log level to &quot;WARN&quot;.</span><br><span class="line">To adjust logging level use sc.setLogLevel(newLevel). For SparkR, use setLogLevel(newLevel).</span><br><span class="line">Spark context Web UI available at http://192.168.36.116:4040</span><br><span class="line">Spark context available as &#x27;sc&#x27; (master = local[*], app id = local-1617174045126).</span><br><span class="line">Spark session available as &#x27;spark&#x27;.</span><br><span class="line">Welcome to</span><br><span class="line">      ____              __</span><br><span class="line">     / __/__  ___ _____/ /__</span><br><span class="line">    _\ \/ _ \/ _ `/ __/  &#x27;_/</span><br><span class="line">   /___/ .__/\_,_/_/ /_/\_\   version 3.1.1</span><br><span class="line">      /_/</span><br><span class="line">         </span><br><span class="line">Using Scala version 2.12.10 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0_271)</span><br><span class="line">Type in expressions to have them evaluated.</span><br><span class="line">Type :help for more information.</span><br><span class="line"></span><br><span class="line"><span class="meta">scala&gt;</span><span class="bash"> </span></span><br></pre></td></tr></table></figure>
<p><strong>解决二（理论上可行）：</strong>想要和brew安装方式对齐，将spark移动到/usr/local/Cellar下，按brew安装的方式重新建立软连接至/usr/local/bin</p>
<p>首先，将解压后的spark包移动到Cellar目录下，修改文件格式，和其他安装包保持一致，即Cellar/spark/3.1.1/</p>
<p>然后<code>brew link spark</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">Error: Could not symlink sbin/start-all.sh</span><br><span class="line">Target /usr/local/sbin/start-all.sh</span><br><span class="line">is a symlink belonging to hadoop. You can unlink it:</span><br><span class="line">  brew unlink hadoop</span><br></pre></td></tr></table></figure>
<p>提示/usr/local/bin里已经有一个名为 ’start-all.sh‘ 的同名脚本了。也就是hadoop和spark里有脚本名重复了，所以方便起见，采用了第一种解决方案，但是为了/usr/local目录的整洁性，如果可以，还是优先用brew安装，或者靠齐安装目录格式比较好。</p>
]]></content>
      <categories>
        <category>bigdata</category>
      </categories>
      <tags>
        <tag>hadoop</tag>
      </tags>
  </entry>
  <entry>
    <title>内网实现maltego-TDS-transform</title>
    <url>/2021/01/11/%E5%86%85%E7%BD%91%E5%AE%9E%E7%8E%B0maltego-TDS-transform/</url>
    <content><![CDATA[<p>将本地数据库中实体关系通过maltego产品界面进行画布探索展示。maltego产品支持自定义local transform（基于给定节点进行关联节点的探索过程），但是local方式的实现需要用户根据设备的具体情况，对python编译器等进行配置，不方便功能共享和展示。TDS-transform结合内网穿透可以解决分布式操作需求。</p>
<a id="more"></a>

<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>工作任务：</p>
<p>将本地数据库中实体关系通过maltego产品界面进行画布探索展示。maltego产品支持自定义local transform（基于给定节点进行关联节点的探索过程），但是local方式的实现需要用户根据设备的具体情况，对python编译器等进行配置，不方便功能共享和展示。</p>
<p>maltego的另一种transform形式为Transform Distribution Server（TDS），这种方式就是为了解决多人协作情况下的transform开发问题。用户通过简单配置在maltego客户端集成TDS transform组。当执行其中的TDS transform时，客户端发送必要信息（seed, transform name, input entity）请求TDS，TDS执行代理角色，查询对应的transform配置信息，定位到transform代码真正部署的web服务器进行查询。</p>
<p>Maltego的公共TDS服务器<span class="exturl" data-url="aHR0cHM6Ly9jZXRhcy5wYXRlcnZhLmNvbS9URFMvJUVGJUJDJThDJUU2JUIzJUE4JUU1JTg2JThDJUU3JTk5JUJCJUU1JUJEJTk1JUU1JThEJUIzJUU1JThGJUFGJUU0JUJEJUJGJUU3JTk0JUE4JUUzJTgwJTgyJUU1JUFFJUEyJUU2JTg4JUI3JUU3JUFCJUFGJUU5JTg1JThEJUU3JUJEJUFFJUU2JTk3JUI2JUU0JUJCJTg1JUU5JTlDJTgwJUU4JUE2JTgxJUU2JUI3JUJCJUU1JThBJUEwc2VlZCVFNCVCRiVBMSVFNiU4MSVBRiVFMyU4MCU4MiVFNSU5QyVBOCVFOCU4NyVBQSVFNSVBRSU5QSVFNCVCOSU4OXRyYW5zZm9ybSVFNiU5NyVCNiVFOSU5QyU4MCVFOCVBNiU4MSVFNSVBMSVBQiVFNSU4NiU5OXRyYW5zZm9ybSVFNCVCQiVBMyVFNyVBMCU4MSVFNiU4OSU4MCVFNSU5QyVBOCVFNyU5QSU4NHNlcnZlciVFNSU5QyVCMCVFNSU5RCU4MCVFMyU4MCU4Mg==">https://cetas.paterva.com/TDS/，注册登录即可使用。客户端配置时仅需要添加seed信息。在自定义transform时需要填写transform代码所在的server地址。<i class="fa fa-external-link-alt"></i></span></p>
<img data-src="/images/内网实现maltego-TDS-transform/image-20210111171505571.png" alt="image-20210111171505571" style="zoom:50%;" />



<p><strong>需要解决的问题</strong>：maltego提供公共TDS的使用，python第三方库maltego-trx提供了transform开发工具包和运行transform server的模板。因此唯一需要解决的就是TDS和transform server间通信。需要一台公网可访问的web服务器运行transform server。</p>
<p><strong>方法</strong>：基于ngrok实现内网穿透。<span class="exturl" data-url="aHR0cHM6Ly95aW5qaWFuZ3lpLmdpdGh1Yi5pby8yMDIxLzAxLzA5L25naW54K05ncm9rJUU1JTlDJUE4bWFjJUU0JUI4JThCJUU1JUFFJTlFJUU3JThFJUIwJUU1JTg2JTg1JUU3JUJEJTkxJUU3JUE5JUJGJUU5JTgwJThGLw==">Ngrok在mac下实现内网穿透<i class="fa fa-external-link-alt"></i></span></p>
<h2 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h2><p>主要步骤：</p>
<ul>
<li><p>环境：python，maltego-trx，clickhouse</p>
</li>
<li><p>开发transform代码</p>
<ul>
<li><p>需要在maltigo-trx代码中添加新增实体</p>
<p><img data-src="/images/%E5%86%85%E7%BD%91%E5%AE%9E%E7%8E%B0maltego-TDS-transform/image-20210111165020200.png" alt="image-20210111165020200"></p>
</li>
<li><p><code>python project.py list</code> 测试代码</p>
</li>
<li><p><code>python project.py runserver</code></p>
</li>
</ul>
</li>
<li><p>内网穿透</p>
<ul>
<li>安装ngrok，修改端口，运行映射</li>
</ul>
</li>
<li><p>配置TDS</p>
</li>
</ul>
<h3 id="1-开发transform代码"><a href="#1-开发transform代码" class="headerlink" title="1. 开发transform代码"></a>1. 开发transform代码</h3><ul>
<li><p>安装第三方python库 <code>pip install  maltego-trx</code></p>
</li>
<li><p>在自定路径中新建工程目录 <code>maltego-trx start your_project_name</code>，生成目录中包括project.py文件和transform文件夹。</p>
</li>
<li><p>在transform文件夹中新建py文件开发transform代码。</p>
<ul>
<li>过程中如果需要定义其他类别实体，如客户端ip，需要在修改maltego-trx中entites.py，添加实体名和ip。添加后即可正常运行。</li>
<li>在客户端中创建实体集合set（可选，方便查找），在集合中添加实体，定义实体logo等。</li>
</ul>
</li>
</ul>
<h3 id="2-配置TDS"><a href="#2-配置TDS" class="headerlink" title="2. 配置TDS"></a>2. 配置TDS</h3><ul>
<li><p>public TDS[地址]，注册、登录。</p>
</li>
<li><p>添加transform</p>
<img data-src="/images/内网实现maltego-TDS-transform/image-20210111164025867.png" alt="image-20210111164025867"  />

<ul>
<li><p>自定义name和UI Display</p>
</li>
<li><p>Transform URL</p>
<p>cd进项目目录，运行 <code>python project.py runserver</code></p>
<p><img data-src="/images/%E5%86%85%E7%BD%91%E5%AE%9E%E7%8E%B0maltego-TDS-transform/image-20210111164604629.png" alt="image-20210111164604629"></p>
<p>这里列出的就是已经开发好的transforms。</p>
<p>在transform配置的图中，URL为 <span class="exturl" data-url="aHR0cDovLzA4MTEyZTIwYzgxNC5uZ3Jvay5pby9ydW4vbWFpbHRvbWFpbCVFRiVCQyU4QyVFNSU4NSVCNiVFNCVCOCVBRGh0dHA6Ly8wODExMmUyMGM4MTQubmdyb2suaW8=">http://08112e20c814.ngrok.io/run/mailtomail，其中http://08112e20c814.ngrok.io<i class="fa fa-external-link-alt"></i></span> 是ngrok分配的域名，如果是未经过穿透直接可访问的公网server，这里为<span class="exturl" data-url="aHR0cDovL3NlcnZlcl9pcDpwb3J077yMYC9ydW4vbWFpbHRvbWFpbGA=">http://server_ip:port，`/run/mailtomail`<i class="fa fa-external-link-alt"></i></span> 按transform server urls列表中添加。</p>
</li>
<li><p>选择input entity。如果是自定义，按照代码中添加的实体ID进行添加（cybernarrator.ClientIP）：</p>
<p><img data-src="/images/%E5%86%85%E7%BD%91%E5%AE%9E%E7%8E%B0maltego-TDS-transform/image-20210111165020200.png" alt="image-20210111165020200"></p>
</li>
<li><p>transform添加成功。</p>
</li>
<li><p>seeds选择默认即可。</p>
</li>
</ul>
</li>
<li><p>客户端配置</p>
<ul>
<li><p>自定义代码中添加的实体类别。</p>
<img data-src="/images/内网实现maltego-TDS-transform/image-20210111165329645.png" alt="image-20210111165329645" style="zoom:67%;" />

<p>这里的unique type name必须和代码中的id一致。可以添加一个合适icon，便于区分。或者直接进行导入。</p>
</li>
<li><p>TDS seed添加到客户端</p>
<p>TDS web interface中，点击seeds，复制url</p>
<img data-src="/images/内网实现maltego-TDS-transform/image-20210111170025189.png" alt="image-20210111165941925" style="zoom:50%;" />

<img data-src="/images/内网实现maltego-TDS-transform/image-20210111170050676.png" alt="image-20210111170050676" style="zoom:50%;" />

<p>进入maltego客户端，点击transform-&gt;transform hub，添加tranform。自定义ID和name，将复制的seed url粘贴过来，补充其他描述内容，OK。</p>
<img data-src="/images/内网实现maltego-TDS-transform/image-20210111170455362.png" alt="image-20210111170455362" style="zoom:67%;" />

<p>完成添加后，install安装。</p>
<img data-src="/images/内网实现maltego-TDS-transform/image-20210111170553250.png" alt="image-20210111170553250" style="zoom: 67%;" />

<p>安装完成后，查看transform-&gt;transform manager -&gt; transform Server -&gt; default，开发的transform已经添加完成</p>
<img data-src="/images/内网实现maltego-TDS-transform/image-20210111170907163.png" alt="image-20210111170907163" style="zoom:67%;" /></li>
</ul>
</li>
</ul>
<h3 id="3-使用"><a href="#3-使用" class="headerlink" title="3 使用"></a>3 使用</h3><p>客户端点击创建graph图标，即可进行实体添加和transform运行。</p>
<p><img data-src="/images/%E5%86%85%E7%BD%91%E5%AE%9E%E7%8E%B0maltego-TDS-transform/image-20210111171002971.png" alt="image-20210111171002971"></p>
<img data-src="/images/内网实现maltego-TDS-transform/image-20210111171140927.png" alt="image-20210111171140927" style="zoom:67%;" />

<img data-src="/images/内网实现maltego-TDS-transform/image-20210111171224959.png" alt="image-20210111171224959" style="zoom:67%;" />

<img data-src="/images/内网实现maltego-TDS-transform/image-20210111171316270.png" alt="image-20210111171316270" style="zoom:67%;" />]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>HTTP服务</tag>
        <tag>OSNIT</tag>
      </tags>
  </entry>
  <entry>
    <title>读书笔记-美丽新世界</title>
    <url>/2021/01/13/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0-%E7%BE%8E%E4%B8%BD%E6%96%B0%E4%B8%96%E7%95%8C/</url>
    <content><![CDATA[<p>人们忧心忡忡的1984并没有如期而至，而赫胥黎所预言的美丽新世界却在日益成为现实。——Neil Postman ，《娱乐至死》</p>
<p>如果说奥威尔的《1984》里，人们为失去自由而痛苦，那么赫胥黎的《美丽新世界》里，人们则为了摆脱自由的重负而狂喜。——《美丽新世界》代序</p>
<a id="more"></a>

<img data-src="/images/读书笔记-美丽新世界/ZHznkAiIOd91uy.jpg!l" alt="美丽新世界【下载在线阅读书评】" style="zoom:50%;" />

<p>《美丽新世界》是世界三大反乌托邦小说之一。《美丽新世界》为世人所知，很大程度上归功于尼尔波特曼的畅销书《娱乐至死》。</p>
<p>书中描写的是一个科技高度发达的社会，物质享受极其丰富。基因培养技术替代传统生育方式批量“生产”新生命。公民被按照严格比例进行等级划分，并且经过流程化的洗脑和教育实现“幸福钢印”。所有的负面情绪，包括嫉妒、恐惧、愤怒，都可以通过吞食“Soma”，一种致幻毒品，轻易被消除。也同样为了避免负面情绪可能带来的社会动荡，一切可能产生冲动的热爱——爱情、亲情、历史、艺术、对真理的探索、对死亡的恐惧，都被消除。所有人被寄予无限的“幸福”，当然“幸福”的标准也是被规定好的。</p>
<p>简单来说，关于<strong>成为痛苦的苏格拉底还是一头快乐的猪</strong>，统治者为所有人做出了选择。</p>
<p>主人公John是一个在保留区长大的“野蛮人”，他接触了莎士比亚并热爱文学，信仰上帝。在来到了文明的城市之后，无法接受所谓文明寄予人的廉价的幸福，坚定的为自己争取经历苦难的权利，在发现自己对贝塔列宁娜产生了难以控制的肉欲之后，选择被流放，通过鞭打对自己净化和救赎。但最终发现仍旧无法逃离内心的欲望，绝望的选择自杀。</p>
<p>我最爱的部分是John流放前和总管穆斯塔法的交流。穆斯塔法从哲学家的梦想谈起（“天地之间万事万物，而哲学家梦想的东西却寥寥无几”），阐述世界的自洽之处。读《1984》的时候，恐惧感非常真实，但是温斯顿觉醒之后的二次同化我并不能完全感同身受。我始终认为恐惧无法让一个灵魂完全屈服。相反“美丽新世界”似乎更具有说服力。</p>
<p>我能看到那个世界的申请在现实生活中逐渐清晰。<strong>当没有价值的娱乐占满我生活中的所有缝隙的时候，当现实的压力碾碎了所有的热爱和梦想的时候，价值是否还是价值本身，我是否能够坚定地拒绝卑劣廉价的幸福，受尽苦难去拥护着人生的那份动荡，那份宏伟壮观。</strong></p>
]]></content>
      <categories>
        <category>读书</category>
      </categories>
      <tags>
        <tag>读书笔记</tag>
        <tag>反乌托邦</tag>
      </tags>
  </entry>
  <entry>
    <title>DDos攻击与保护</title>
    <url>/2021/07/12/DDos%E6%94%BB%E5%87%BB%E4%B8%8E%E4%BF%9D%E6%8A%A4/</url>
    <content><![CDATA[<p>DoS是Denial of Service的简称，即拒绝服务，造成DoS的攻击行为被称为DoS攻击，其目的是使计算机或网络无法提供正常的服务。最常见的DoS攻击有计算机网络宽带攻击和连通性攻击。 DoS攻击是指故意的攻击网络协议实现的缺陷或直接通过野蛮手段残忍地耗尽被攻击对象的资源，目的是让使目标系统服务系统停止响应甚至崩溃。这些服务资源包括网络带宽，文件系统空间容量，开放的进程或者允许的连接。这种攻击会导致资源的匮乏，无论计算机的处理速度多快、内存容量多大、网络带宽的速度多快都无法避免这种攻击带来的后果。 </p>
<a id="more"></a>

<h2 id="1-什么是DDos攻击"><a href="#1-什么是DDos攻击" class="headerlink" title="1. 什么是DDos攻击"></a>1. 什么是DDos攻击</h2><h3 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h3><p>Distribution Denial-of-Service 分布式拒绝服务。</p>
<h4 id="如何识别"><a href="#如何识别" class="headerlink" title="如何识别"></a>如何识别</h4><p>明显迹象：</p>
<ul>
<li>来自单个 IP 地址或 IP 范围的可疑流量</li>
<li>来自共享单个行为特征（例如设备类型、地理位置或 Web 浏览器版本）的用户的大量流量</li>
<li>对单个页面或端点的请求数量出现不明原因的激增</li>
<li>奇怪的流量模式，例如一天中非常规时间段的激增或看似不自然的模式（例如，每 10 分钟出现一次激增）</li>
<li>DDoS 攻击还有其他更具体的迹象，具体取决于攻击的类型。</li>
</ul>
<h3 id="常见攻击类别（简要介绍）"><a href="#常见攻击类别（简要介绍）" class="headerlink" title="常见攻击类别（简要介绍）"></a>常见攻击类别（简要介绍）</h3><img data-src="/images/DDos%E6%94%BB%E5%87%BB%E4%B8%8E%E4%BF%9D%E6%8A%A4/image-20210712180840976.png" alt="image-20210712180840976" style="zoom: 50%;" />

<h4 id="应用层攻击"><a href="#应用层攻击" class="headerlink" title="应用层攻击"></a>应用层攻击</h4><p>此类攻击有时称为<span class="exturl" data-url="aHR0cHM6Ly93d3cuY2xvdWRmbGFyZS5jb20vbGVhcm5pbmcvZGRvcy93aGF0LWlzLWxheWVyLTcv">第 7 层<i class="fa fa-external-link-alt"></i></span> DDoS 攻击（指 OSI 模型第 7 层），其目标是耗尽目标资源。</p>
<p>攻击目标是生成网页并传输网页响应HTTP请求的服务器应用层，在客户端执行HTTP请求的计算成本很低，但是目标服务器做出响应的成本很高。防御难度较大，因为难以区分恶意流量和合法流量。</p>
<img data-src="/images/DDos%E6%94%BB%E5%87%BB%E4%B8%8E%E4%BF%9D%E6%8A%A4/http-flood-ddos-attack.png" alt="http-flood-ddos-attack" style="zoom:25%;" />

<h5 id="HTTP-flood"><a href="#HTTP-flood" class="headerlink" title="HTTP flood"></a>HTTP flood</h5><p>HTTP 洪水攻击类似于同时在大量不同计算机的 Web 浏览器中一次又一次地按下刷新 ——大量 HTTP 请求涌向服务器，导致拒绝服务。</p>
<p>这种类型的攻击有简单的，也有复杂的。较简单的实现可以使用相同范围的攻击 IP 地址、referrer 和用户代理访问一个 URL。复杂版本可能使用大量 IP 地址，并使用随机 referrer 和用户代理来绕过检测。</p>
<h4 id="协议攻击"><a href="#协议攻击" class="headerlink" title="协议攻击"></a>协议攻击</h4><p>协议攻击也称为状态耗尽攻击，这类攻击会过度消耗服务器资源和/或<span class="exturl" data-url="aHR0cHM6Ly93d3cuY2xvdWRmbGFyZS5jb20vbGVhcm5pbmcvc2VjdXJpdHkvd2hhdC1pcy1hLWZpcmV3YWxsLw==">防火墙<i class="fa fa-external-link-alt"></i></span>和负载平衡器之类的网络设备资源，从而导致服务中断。</p>
<p>协议攻击利用协议堆栈第 3 层和第 4 层的弱点致使目标无法访问。</p>
<img data-src="/images/DDos%E6%94%BB%E5%87%BB%E4%B8%8E%E4%BF%9D%E6%8A%A4/syn-flood-ddos-attack.png" alt="syn-flood-ddos-attack" style="zoom:15%;" />

<h5 id="TCP-SYN攻击"><a href="#TCP-SYN攻击" class="headerlink" title="TCP SYN攻击"></a>TCP SYN攻击</h5><p> <span class="exturl" data-url="aHR0cHM6Ly93d3cuY2xvdWRmbGFyZS5jb20vbGVhcm5pbmcvZGRvcy9zeW4tZmxvb2QtZGRvcy1hdHRhY2sv">SYN 洪水<i class="fa fa-external-link-alt"></i></span>就好比补给室中的工作人员从商店的柜台接收请求。</p>
<p>工作人员收到请求，前去取包裹，再等待确认，然后将包裹送到柜台。工作人员收到太多包裹请求，但得不到确认，直到无法处理更多包裹，实在不堪重负，致使无人能对请求做出回应。</p>
<p>此类攻击利用 <span class="exturl" data-url="aHR0cHM6Ly93d3cuY2xvdWRmbGFyZS5jb20vbGVhcm5pbmcvZGRvcy9nbG9zc2FyeS90Y3AtaXAv">TCP 握手<i class="fa fa-external-link-alt"></i></span>（两台计算机发起网络连接时要经过的一系列通信），通过向目标发送大量带有<span class="exturl" data-url="aHR0cHM6Ly93d3cuY2xvdWRmbGFyZS5jb20vbGVhcm5pbmcvZGRvcy9nbG9zc2FyeS9pcC1zcG9vZmluZy8=">伪造<i class="fa fa-external-link-alt"></i></span>源 IP 地址的 TCP“初始连接请求”SYN 数据包来实现。</p>
<p>目标计算机响应每个连接请求，然后等待握手中的最后一步，但这一步确永远不会发生，因此在此过程中耗尽目标的资源。</p>
<h4 id="容量耗尽攻击"><a href="#容量耗尽攻击" class="headerlink" title="容量耗尽攻击"></a>容量耗尽攻击</h4><p>Volumetric attacks，此类攻击试图通过消耗目标与较大的互联网之间的所有可用带宽来造成拥塞。攻击运用某种放大攻击或其他生成大量流量的手段（如僵尸网络请求），向目标发送大量数据。</p>
<img data-src="https://cloudflare.com/img/learning/ddos/what-is-a-ddos-attack/ntp-amplification-botnet-ddos-attack.png" alt="ntp-amplification-botnet-ddos-attack" style="zoom:20%;" />

<h5 id="DNS-放大"><a href="#DNS-放大" class="headerlink" title="DNS 放大"></a>DNS 放大</h5><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY2xvdWRmbGFyZS5jb20vbGVhcm5pbmcvZGRvcy9kbnMtYW1wbGlmaWNhdGlvbi1kZG9zLWF0dGFjay8=">DNS 放大<i class="fa fa-external-link-alt"></i></span>就好比有人打电话给餐馆说“每道菜都订一份，请给我回电话复述整个订单”，而提供的回电号码实际上属于受害者。几乎不费吹灰之力，就能产生很长的响应并发送给受害者。</p>
<p>利用伪造的 IP 地址（受害者的 IP 地址）向开放式 <span class="exturl" data-url="aHR0cHM6Ly93d3cuY2xvdWRmbGFyZS5jb20vbGVhcm5pbmcvZGRvcy9nbG9zc2FyeS9kb21haW4tbmFtZS1zeXN0ZW0tZG5zLw==">DNS 服务器<i class="fa fa-external-link-alt"></i></span>发出请求后，目标 IP 地址将收到服务器发回的响应。</p>
<h3 id="常见防御手段"><a href="#常见防御手段" class="headerlink" title="常见防御手段"></a>常见防御手段</h3><p>难点在于区分真实客户流量与攻击流量。</p>
<h4 id="黑洞路由"><a href="#黑洞路由" class="headerlink" title="黑洞路由"></a>黑洞路由</h4><p>有一种解决方案几乎适用于所有网络管理员：创建<span class="exturl" data-url="aHR0cHM6Ly93d3cuY2xvdWRmbGFyZS5jb20vbGVhcm5pbmcvZGRvcy9nbG9zc2FyeS9kZG9zLWJsYWNraG9sZS1yb3V0aW5n">黑洞<i class="fa fa-external-link-alt"></i></span>路由，并将流量汇入该路由。在最简单的形式下，当在没有特定限制条件的情况下实施黑洞过滤时，合法网络流量和恶意网络流量都将路由到空路由或黑洞，并从网络中丢弃。</p>
<p>如果互联网设备遭受 DDoS 攻击，则该设备的互联网服务提供商（ISP）可能会将站点的所有流量发送到黑洞中作为防御。这不是理想的解决方案，因为它相当于让攻击者达成预期的目标：使网络无法访问。</p>
<h4 id="速率限制"><a href="#速率限制" class="headerlink" title="速率限制"></a>速率限制</h4><p>限制服务器在某个时间段接收的请求数量也是防护拒绝服务攻击的一种方法。虽然速率限制对于减缓 Web 爬虫窃取内容及防护<span class="exturl" data-url="aHR0cHM6Ly93d3cuY2xvdWRmbGFyZS5jb20vbGVhcm5pbmcvYm90cy9icnV0ZS1mb3JjZS1hdHRhY2sv">暴力破解<i class="fa fa-external-link-alt"></i></span>攻击很有帮助，但仅靠速率限制可能不足以有效应对复杂的 DDoS 攻击。然而，在高效 DDoS 防护策略中，速率限制不失为一种有效手段。</p>
<h4 id="Web-应用程序防火墙"><a href="#Web-应用程序防火墙" class="headerlink" title="Web 应用程序防火墙"></a>Web 应用程序防火墙</h4><p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY2xvdWRmbGFyZS5jb20vbGVhcm5pbmcvZGRvcy9nbG9zc2FyeS93ZWItYXBwbGljYXRpb24tZmlyZXdhbGwtd2FmLw==">Web 应用程序防火墙（WAF）<i class="fa fa-external-link-alt"></i></span> 是一种有效工具，有助于缓解第 7 层 DDoS 攻击。在互联网和源站之间部署 WAF 后，WAF 可以充当<span class="exturl" data-url="aHR0cHM6Ly93d3cuY2xvdWRmbGFyZS5jb20vbGVhcm5pbmcvY2RuL2dsb3NzYXJ5L3JldmVyc2UtcHJveHkv">反向代理<i class="fa fa-external-link-alt"></i></span>，保护目标服务器，防止其遭受特定类型的恶意流量入侵。</p>
<p>通过基于一系列用于识别 DDoS 工具的规则筛选请求，可以阻止第 7 层攻击。有效的 WAF 的一个关键价值是能够快速实施自定义规则以应对攻击。</p>
<h4 id="Anycast-网络扩散"><a href="#Anycast-网络扩散" class="headerlink" title="Anycast 网络扩散"></a>Anycast 网络扩散</h4><p>此类缓解方法使用 Anycast 网络，将攻击流量分散至分布式服务器网络，直到网络吸收流量为止。</p>
<p>这种方法就好比将湍急的河流引入若干独立的小水渠，将分布式攻击流量的影响分散到可以管理的程度，从而分散破坏力。</p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY2xvdWRmbGFyZS5jb20vbGVhcm5pbmcvY2RuL2dsb3NzYXJ5L2FueWNhc3QtbmV0d29yay8=">Anycast 网络<i class="fa fa-external-link-alt"></i></span>在缓解 DDoS 攻击方面的可靠性取决于攻击规模及网络规模和效率。采用 Anycast 分布式网络是 Cloudflare 实施 DDoS防护策略的一个重要组成部分。</p>
<p>Cloudflare 拥有 67 Tbps 的网络，比有记录的最大 DDoS 攻击大一个数量级。</p>
<h2 id="2-常见攻击类别"><a href="#2-常见攻击类别" class="headerlink" title="2. 常见攻击类别"></a>2. 常见攻击类别</h2><h3 id="2-1-内存缓存-DDoS-攻击"><a href="#2-1-内存缓存-DDoS-攻击" class="headerlink" title="2.1 内存缓存 DDoS 攻击"></a>2.1 内存缓存 DDoS 攻击</h3><p>memcached DDoS attack</p>
<p>内存缓存<span class="exturl" data-url="aHR0cHM6Ly93d3cuY2xvdWRmbGFyZS5jb20vbGVhcm5pbmcvZGRvcy93aGF0LWlzLWEtZGRvcy1hdHRhY2sv">分布式拒绝服务 (DDoS) <i class="fa fa-external-link-alt"></i></span>攻击是一种网络攻击，攻击者试图使目标受害者的网络流量超载。攻击者将欺骗性的请求发送到易受攻击的UDP内存缓存服务器，该服务器随后向目标受害者发送 Internet 流量，从而可能使受害者的资源不堪重负。当目标的 Internet 基础设施过载时，就无法处理新请求，而常规流量也无法访问Internet 资源，从而导致<span class="exturl" data-url="aHR0cHM6Ly93d3cuY2xvdWRmbGFyZS5jb20vbGVhcm5pbmcvZGRvcy9nbG9zc2FyeS9kZW5pYWwtb2Ytc2VydmljZS8=">拒绝服务<i class="fa fa-external-link-alt"></i></span>。</p>
<p>内存缓存是用于加速网站和网络的数据库缓存系统。</p>
<h4 id="攻击原理"><a href="#攻击原理" class="headerlink" title="攻击原理"></a>攻击原理</h4><p>内存缓存攻击的工作方式类似于所有 DDoS 放大攻击，例如<span class="exturl" data-url="aHR0cHM6Ly93d3cuY2xvdWRmbGFyZS5jb20vbGVhcm5pbmcvZGRvcy9udHAtYW1wbGlmaWNhdGlvbi1kZG9zLWF0dGFjay8="> NTP 放大<i class="fa fa-external-link-alt"></i></span>和<span class="exturl" data-url="aHR0cHM6Ly93d3cuY2xvdWRmbGFyZS5jb20vbGVhcm5pbmcvZGRvcy9kbnMtYW1wbGlmaWNhdGlvbi1kZG9zLWF0dGFjay8="> DNS 放大<i class="fa fa-external-link-alt"></i></span>。这种攻击欺骗性请求发送到易受攻击的服务器，该服务器随后会发出比初始请求大的数据量作为响应，因此放大了流量。</p>
<p>内存缓存放大攻击就好比是一个心怀恶意的青少年打电话给一家餐厅说“我要菜单上的东西每样来一份，请给我回电话并告诉我整个订单的信息”。当餐厅询问回叫号码时，他却给出目标受害者的电话号码。然后，目标会收到来自餐厅的呼叫，接到他们未请求的大量信息。</p>
<p><strong>这种放大攻击的方法之所以成为可能，因为内存缓存服务器可以选择使用 UDP 协议进行操作。UDP允许在不首先获得所谓握手的情况下发送数据 - 握手是指双方都同意通信的网络过程。之所以使用 UDP，是因为不用咨询目标主机是否愿意接收数据，无需事先征得它们的同意，就可以将大量数据发送给目标主机。</strong></p>
<p><strong>内存缓存攻击分为 4 个步骤：</strong></p>
<ol>
<li>攻击者将大量数据有效载荷*植入暴露的内存缓存服务器上。</li>
<li>接下来，攻击者使用目标受害者的IP 地址伪造HTTP GET请求。</li>
<li>带有漏洞的内存缓存服务器接收到请求，试图通过响应来提供帮助，因此将大量响应发送到目标。</li>
<li>目标服务器或其周围的基础设施无法处理从内存缓存服务器发送的大量数据，因此导致过载和对正常请求拒绝服务。</li>
</ol>
<p><strong>内存缓存放大攻击的规模可以达到多大？</strong></p>
<p>这种攻击的放大倍数十分惊人；在实践中，我们见过高达 51,200 倍的放大倍数！这意味着对于 15 字节的请求，可以发送 750 kB 的响应。这是一个巨大的放大倍数，无法承受如此大量攻击流量的 Web 资产则面临巨大的安全风险。巨大的放大倍数加上带有漏洞的服务器使内存缓存放大攻击成为攻击者针对各种目标发起 DDoS 攻击的主要用例。</p>
<h4 id="如何防护"><a href="#如何防护" class="headerlink" title="如何防护"></a>如何防护</h4><ol>
<li><strong>禁用 UDP</strong> - 对于内存缓存服务器，请确保在不需要时禁用 UDP 支持。默认情况下，内存缓存启用了 UDP 支持，这可能会使服务器容易受到攻击。</li>
<li><strong>对内存缓存服务器进行防火墙保护</strong> - 通过在内存缓存服务器和 Internet 之间添加<span class="exturl" data-url="aHR0cHM6Ly93d3cuY2xvdWRmbGFyZS5jb20vbGVhcm5pbmcvc2VjdXJpdHkvd2hhdC1pcy1hLWZpcmV3YWxsLw==">防火墙<i class="fa fa-external-link-alt"></i></span>保护，系统管理员可以根据需要使用 UDP，而不必暴露于风险中。</li>
<li><strong>防止 IP 欺骗</strong> - 只要可以伪造 IP 地址，DDoS 攻击就可以利用此漏洞将流量定向到受害者的网络。防止 IP 欺骗是一个规模较大的解决方案，无法由特定的系统管理员实施，它要求传输提供商禁止源 IP 地址源自网络外部的任何数据包离开其网络。换句话说，Internet 服务提供商 (ISP) 之类的公司必须筛选流量，以使离开其网络的数据包不得假装成来自其他地方的其他网络。如果所有主要的传输提供商都实施了这种筛选，基于欺骗的攻击将在一夜之间消失。</li>
<li><strong>开发具有减少 UDP 响应的软件</strong> - 消除放大攻击的另一种方法是<strong>去除任何传入请求的放大因素</strong>；如果由于 UDP 请求而发送的响应数据小于或等于初始请求，则放大就不复可能。</li>
</ol>
<p>Cloudflare 在网络边缘筛选 UDP 流量，消除了诸如此类的放大攻击带来的风险。探索 Cloudflare 的<span class="exturl" data-url="aHR0cHM6Ly93d3cuY2xvdWRmbGFyZS5jb20vZGRvcy8=">高级 DDoS <i class="fa fa-external-link-alt"></i></span>防护。</p>
<p>要更深入地了解 Cloudflare 遇到内存缓存攻击的情况以及用于防护的特定命令和过程，请浏览博客文章<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNsb3VkZmxhcmUuY29tL21lbWNyYXNoZWQtbWFqb3ItYW1wbGlmaWNhdGlvbi1hdHRhY2tzLWZyb20tcG9ydC0xMTIxMS8=">内存缓存 - 来自 UDP 端口 11211 <i class="fa fa-external-link-alt"></i></span>的主要放大攻击。</p>
<h3 id="2-2-SYN-Flood攻击"><a href="#2-2-SYN-Flood攻击" class="headerlink" title="2.2 SYN Flood攻击"></a>2.2 SYN Flood攻击</h3><h4 id="攻击原理-1"><a href="#攻击原理-1" class="headerlink" title="攻击原理"></a>攻击原理</h4><p>SYN 洪水攻击利用 <span class="exturl" data-url="aHR0cHM6Ly93d3cuY2xvdWRmbGFyZS5jb20vbGVhcm5pbmcvZGRvcy9nbG9zc2FyeS90Y3AtaXAv">TCP<i class="fa fa-external-link-alt"></i></span> 连接的握手过程发动攻击。正常情况下，TCP 连接将完成三次握手以建立连接。</p>
<ol>
<li>首先，客户端向服务器发送 SYN 数据包以发起连接。</li>
<li>接着，服务器通过 SYN/ACK 数据包对该初始数据包做出响应，以便确认通信。</li>
<li>最后，客户端返回 ACK 数据包以确认接到服务器发出的数据包。完成这一系列数据包发送和接收操作后，TCP 连接将处于打开状态并且能够发送和接收数据。</li>
</ol>
<img data-src="/images/DDos%E6%94%BB%E5%87%BB%E4%B8%8E%E4%BF%9D%E6%8A%A4/syn-flood-attack-ddos-attack-diagram-1.png" alt="syn-flood-attack-ddos-attack-diagram-1" style="zoom: 33%;" />

<p>为发起<span class="exturl" data-url="aHR0cHM6Ly93d3cuY2xvdWRmbGFyZS5jb20vbGVhcm5pbmcvZGRvcy9nbG9zc2FyeS9kZW5pYWwtb2Ytc2VydmljZS8=">拒绝服务<i class="fa fa-external-link-alt"></i></span>攻击，攻击者需利用这样一项事实：收到初始 SYN 数据包后，服务器将通过一个或多个 SYN/ACK 数据包做出回响，等待完成握手过程的最后一步。工作方式如下：</p>
<ol>
<li>攻击者通常使用<span class="exturl" data-url="aHR0cHM6Ly93d3cuY2xvdWRmbGFyZS5jb20vbGVhcm5pbmcvZGRvcy9nbG9zc2FyeS9pcC1zcG9vZmluZy8=">伪造的<i class="fa fa-external-link-alt"></i></span> IP 地址向目标服务器发送大量 SYN 数据包。</li>
<li>然后，服务器分别对每一项连接请求做出响应，并确保打开的端口做好接收响应的准备。</li>
<li>在服务器等待最后一个 ACK 数据包（永远不会到达）的过程中，攻击者将继续发送更多 SYN 数据包。每当有新的 SYN 数据包到达，服务器都会临时打开一个新的端口并在一段特定时间内保持连接；用遍所有可用端口后，服务器将无法正常运行。</li>
</ol>
<img data-src="/images/DDos%E6%94%BB%E5%87%BB%E4%B8%8E%E4%BF%9D%E6%8A%A4/syn-flood-attack-ddos-attack-diagram-2.png" alt="syn-flood-attack-ddos-attack-diagram-2" style="zoom:25%;" />

<p>在网络中，如果服务器连接处于打开状态但另一端的机器连接未打开，则视为半开连接。在此类 DDoS 攻击中，目标服务器将使连接一直处于打开状态，静待各个连接超时，避免再次开放端口。因此，此类攻击可视为<strong>“半开连接攻击”</strong>。</p>
<p><strong>恶意用户可通过三种不同方式发起 SYN 洪水攻击：</strong></p>
<ol>
<li><strong>直接攻击：</strong>不伪造 <span class="exturl" data-url="aHR0cHM6Ly93d3cuY2xvdWRmbGFyZS5jb20vbGVhcm5pbmcvZG5zL2dsb3NzYXJ5L3doYXQtaXMtbXktaXAtYWRkcmVzcy8=">IP 地址<i class="fa fa-external-link-alt"></i></span>的 SYN 洪水攻击称为直接攻击。在此类攻击中，攻击者完全不屏蔽其 IP 地址。由于攻击者使用具有真实 IP 地址的单一源设备发起攻击，因此很容易发现并清理攻击者。为使目标机器呈现半开状态，黑客将阻止个人机器对服务器的 SYN-ACK 数据包做出响应。为此，通常采用以下两种方式实现：部署<span class="exturl" data-url="aHR0cHM6Ly93d3cuY2xvdWRmbGFyZS5jb20vbGVhcm5pbmcvc2VjdXJpdHkvd2hhdC1pcy1hLWZpcmV3YWxsLw==">防火墙<i class="fa fa-external-link-alt"></i></span>规则，阻止除 SYN 数据包以外的各类传出数据包；或者，对传入的所有 SYN-ACK 数据包进行过滤，防止其到达恶意用户机器。这种方法防护起来难度较小，所以并不常见</li>
<li><strong>欺骗攻击：</strong>恶意用户还可以伪造其发送的各个 SYN 数据包的 IP 地址，以增加防护难度。虽然数据包可能经过伪装，但还是可以通过这些数据包追根溯源。</li>
<li><strong>分布式攻击（DDoS）：</strong>如果使用僵尸网络发起攻击，则追溯攻击源头的可能性很低。攻击者可能还会命令每台分布式设备伪造其发送数据包的 IP 地址。</li>
</ol>
<p>恶意用户可以通过 SYN 洪水攻击尝试在目标设备或服务中创建拒绝服务，<strong>其流量远低于其他 DDoS 攻击</strong>。SYN 攻击不属于容量耗尽攻击，其目的并非使目标周围的网络基础设施达到饱和，只需保证大于目标操作系统的可用积压工作即可。如果攻击者能够确定积压工作规模以及每个连接保持打开状态的时间长度（超出时间将进入超时状态），攻击者将可以找出禁用系统所需的确切参数，从而将创建拒绝服务所需的总流量降至最低。</p>
<h4 id="防护手段"><a href="#防护手段" class="headerlink" title="防护手段"></a>防护手段</h4><h5 id="扩展积压工作队列"><a href="#扩展积压工作队列" class="headerlink" title="扩展积压工作队列"></a>扩展积压工作队列</h5><p>目标设备安装的每个操作系统都允许具有一定数量的半开连接。若要响应大量 SYN 数据包，一种方法是增加操作系统允许的最大半开连接数目。为成功扩展最大积压工作，系统必须额外预留内存资源以处理各类新请求。如果系统没有足够的内存，无法应对增加的积压工作队列规模，将对系统性能产生负面影响，但仍然好过拒绝服务。</p>
<h5 id="回收最先创建的-TCP-半开连接"><a href="#回收最先创建的-TCP-半开连接" class="headerlink" title="回收最先创建的 TCP 半开连接"></a>回收最先创建的 TCP 半开连接</h5><p>另一种缓解策略是在填充积压工作后覆盖最先创建的半开连接。这项策略要求完全建立合法连接的时间低于恶意 SYN 数据包填充积压工作的时间。当攻击量增加或积压工作规模小于实际需求时，这项特定的防御措施将不奏效。</p>
<h5 id="SYN-Cookie"><a href="#SYN-Cookie" class="headerlink" title="SYN Cookie"></a>SYN Cookie</h5><p>此策略要求服务器创建 Cookie。为避免在填充积压工作时断开连接，服务器使用 SYN-ACK 数据包响应每一项连接请求，而后从积压工作中删除 SYN 请求，同时从内存中删除请求，保证端口保持打开状态并做好重新建立连接的准备。如果连接是合法请求并且已将最后一个 ACK 数据包从客户端机器发回服务器，服务器将重建（存在一些限制）SYN 积压工作队列条目。虽然这项缓解措施势必会丢失一些 TCP 连接信息，但好过因此导致对合法用户发起拒绝服务攻击。</p>
<h5 id="Cloudflare-如何缓解-SYN-洪水攻击？"><a href="#Cloudflare-如何缓解-SYN-洪水攻击？" class="headerlink" title="Cloudflare 如何缓解 SYN 洪水攻击？"></a>Cloudflare 如何缓解 SYN 洪水攻击？</h5><p>Cloudflare 通过隔离目标服务器与 SYN 洪水攻击来缓解此类攻击。当发出初始 SYN 请求时，Cloudflare 将在云中完成握手过程，拒绝与目标服务器建立连接，直到完成 TCP 握手过程。</p>
<img data-src="/images/DDos%E6%94%BB%E5%87%BB%E4%B8%8E%E4%BF%9D%E6%8A%A4/syn-flood-attack-ddos-attack-diagram-3.png" alt="Cloudflare 阻止 SYN Flood 攻击图" style="zoom:25%;" />

<h3 id="2-3-ICMP-Flood攻击"><a href="#2-3-ICMP-Flood攻击" class="headerlink" title="2.3 ICMP Flood攻击"></a>2.3 ICMP Flood攻击</h3><p>也叫Ping Flood攻击</p>
<h5 id="攻击原理-2"><a href="#攻击原理-2" class="headerlink" title="攻击原理"></a>攻击原理</h5><p>ICMP Flood（即ICMP 洪水攻击）：当 ICMP ping 产生的大量回应请求超出了系统的最大限度，以至于系统耗费所有资源来进行响应直至再也无法处理有效 的网络信息流，这就是 ICMP 洪水攻击。简单说攻击者向一个子网的广播地址发送多个ICMP Echo请求数据包。并将源地址伪装成想要攻击的目标主机的地址。然后该子网上的所有主机均会对此ICMP Echo请求包作出答复，向被攻击的目标主机发送数据包，使此主机受到攻击，导致网络阻塞。ICMP Flood攻击主要的目的使网络瘫痪。</p>
<p>Ping Flood 的破坏性影响与向目标服务器发出的请求数量成正比。与<span class="exturl" data-url="aHR0cHM6Ly93d3cuY2xvdWRmbGFyZS5jb20vbGVhcm5pbmcvZGRvcy9udHAtYW1wbGlmaWNhdGlvbi1kZG9zLWF0dGFjay8=">NTP放大<i class="fa fa-external-link-alt"></i></span>、<span class="exturl" data-url="aHR0cHM6Ly93d3cuY2xvdWRmbGFyZS5jb20vbGVhcm5pbmcvZGRvcy9kbnMtYW1wbGlmaWNhdGlvbi1kZG9zLWF0dGFjay8=">DNS放大<i class="fa fa-external-link-alt"></i></span>等基于反射的DDoS攻击不同，Ping Flood攻击流量是对称的；目标设备接收的带宽量只是从每个机器人发送的总流量的总和。</p>
<p>参考：</p>
<p><span class="exturl" data-url="aHR0cHM6Ly93d3cuY2xvdWRmbGFyZS5jb20vbGVhcm5pbmcv">https://www.cloudflare.com/learning/<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>安全</category>
      </categories>
      <tags>
        <tag>DDos</tag>
      </tags>
  </entry>
  <entry>
    <title>Superset 上手记录</title>
    <url>/2021/04/21/Superset%E4%B8%8A%E6%89%8B%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<p>Apache Superset是Airbnb开源的数据挖掘平台。支持丰富的数据源连接，多种可视化方式，并能够对用户实现细粒度的权限控制。该工具主要特点是可自助分析、自定义仪表盘、分析结果可视化（导出）、用户/角色权限控制，还集成了一个SQL编辑器，可以进行SQL编辑查询等。最近工作中遇到一个需求，需要基于开源superset实现一个面板。但是安装环境是内网离线环境，踩了不少坑，虽然最后还是用docker搞定，这里还是把之前踩的坑记录一下。</p>
<a id="more"></a>

<p><strong>含泪在卷首血书：</strong></p>
<p><strong>有新不用旧啊！版本兼容问题会被搞到死！</strong></p>
<h1 id="1-关于安装"><a href="#1-关于安装" class="headerlink" title="1. 关于安装"></a>1. 关于安装</h1><h2 id="Mac系统踩坑"><a href="#Mac系统踩坑" class="headerlink" title="Mac系统踩坑"></a>Mac系统踩坑</h2><p>安装方式：</p>
<ul>
<li>基于docker安装：快速方便，但是不适合二次开发，只适合对superset直接进行使用</li>
<li>基于pip安装：快速方便，但是源码需要手动下载，并且版本切换坑比较多</li>
<li>（推荐）基于源码安装：git方便进行版本切换，可以根据网上二次开发的资料完整度checkout到合适的版本进行开发</li>
</ul>
<h4 id="基于docker安装"><a href="#基于docker安装" class="headerlink" title="基于docker安装"></a>基于docker安装</h4><p><strong>安装docker</strong></p>
<p>已安装，顺便更新了一下</p>
<blockquote>
<p>Once you have Docker for Mac installed, open up the preferences pane for Docker, go to the “Resources” section and increase the allocated memory to 6GB. With only the 2GB of RAM allocated by default, Superset will fail to start.</p>
</blockquote>
<p>修改docker内存配置至6GB</p>
<p><strong>拉取superset 仓库</strong></p>
<p><code>git clone https://github.com/apache/superset.git</code> 巨慢</p>
<p><strong>docker中启动superset</strong></p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> <span class="built_in">cd</span> superset</span><br><span class="line"><span class="variable">$</span> git checkout latest</span><br><span class="line"><span class="variable">$</span> docker<span class="literal">-compose</span> up</span><br></pre></td></tr></table></figure>
<p>等待容器下载。下载完毕后找不到文件，未解决……转至install from scratch</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">superset_tests_worker exited with code 127</span><br><span class="line">superset_init exited with code 127</span><br><span class="line">superset_node exited with code 1</span><br><span class="line">superset_worker exited with code 127</span><br><span class="line">superset_worker          | /usr/bin/docker-entrypoint.sh: line 21: /app/docker/docker-bootstrap.sh: No such file or directory</span><br><span class="line">superset_worker          | /usr/bin/docker-entrypoint.sh: line 21: /app/docker/docker-bootstrap.sh: No such file or directory</span><br><span class="line">superset_app exited with code 127</span><br><span class="line">superset_app             | /usr/bin/docker-entrypoint.sh: line 21: /app/docker/docker-bootstrap.sh: No such file or directory</span><br><span class="line">superset_app             | /usr/bin/docker-entrypoint.sh: line 21: /app/docker/docker-bootstrap.sh: No such file or directory</span><br><span class="line">superset_worker exited with code 127</span><br><span class="line">superset_worker          | /usr/bin/docker-entrypoint.sh: line 21: /app/docker/docker-bootstrap.sh: No such file or directory</span><br><span class="line">superset_worker          | /usr/bin/docker-entrypoint.sh: line 21: /app/docker/docker-bootstrap.sh: No such file or directory</span><br><span class="line">superset_worker          | /usr/bin/docker-entrypoint.sh: line 21: /app/docker/docker-bootstrap.sh: No such file or directory</span><br><span class="line">superset_app exited with code 127</span><br><span class="line">superset_app             | /usr/bin/docker-entrypoint.sh: line 21: /app/docker/docker-bootstrap.sh: No such file or directory</span><br><span class="line">superset_app             | /usr/bin/docker-entrypoint.sh: line 21: /app/docker/docker-bootstrap.sh: No such file or directory</span><br><span class="line">superset_app             | /usr/bin/docker-entrypoint.sh: line 21: /app/docker/docker-bootstrap.sh: No such file or directory</span><br><span class="line">superset_worker exited with code 127</span><br></pre></td></tr></table></figure>
<p>错误原因：官网步骤不详细，需要下载superset镜像，创建superset容器，启动容器</p>
<p>参考<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L25pa2V5bGVlL2FydGljbGUvZGV0YWlscy8xMTUyNjQ4MTglRTglQTclQTMlRTUlODYlQjMlRUYlQkMlOEMlRTQlQjglQkIlRTglQTYlODElRTYlQUQlQTUlRTklQUElQTQlRUYlQkMlOUE=">https://blog.csdn.net/nikeylee/article/details/115264818解决，主要步骤：<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight dsconfig"><table><tr><td class="code"><pre><span class="line"><span class="string">docker</span> <span class="string">search</span> <span class="string">superset</span></span><br><span class="line"><span class="string"></span><span class="comment"># 可以自选版本</span></span><br><span class="line"><span class="string">docker</span> <span class="string">pull</span> <span class="string">amancevice</span>/<span class="string">superset</span></span><br><span class="line"><span class="string"></span><span class="comment"># 查看镜像是否下载成功：</span></span><br><span class="line"><span class="string">docker</span> <span class="string">images</span></span><br><span class="line"><span class="string"></span><span class="comment"># 创建Superset容器</span></span><br><span class="line"><span class="comment"># 创建挂载的目录：</span></span><br><span class="line"><span class="string">mkdir</span> /<span class="string">opt</span>/<span class="string">superset</span></span><br><span class="line"><span class="string"></span><span class="comment"># 创建容器</span></span><br><span class="line"><span class="string">docker</span> <span class="string">run</span> <span class="built_in">--name</span> <span class="string">my_superset</span> -<span class="string">d</span> -<span class="string">p</span> <span class="string">8088:8088 </span>-<span class="string">v</span> /<span class="string">opt</span>/<span class="string">superset</span>:/<span class="string">home</span>/<span class="string">superset</span> <span class="string">amancevice</span>/<span class="string">superset</span></span><br><span class="line"><span class="string"></span><span class="comment"># 进入docker镜像</span></span><br><span class="line"><span class="string">docker</span> <span class="string">exec</span> -<span class="string">it</span> <span class="string">my_superset</span> /<span class="string">bin</span>/<span class="string">bash</span></span><br><span class="line"><span class="string"></span><span class="comment"># superset 配置</span></span><br><span class="line"><span class="string">superset</span> <span class="string">db</span> <span class="string">upgrade</span></span><br><span class="line"><span class="string">superset</span> <span class="string">init</span></span><br><span class="line"><span class="string">export</span> <span class="string">FLASK_APP</span>=<span class="string">superset</span></span><br><span class="line"><span class="string">flask</span> <span class="string">fab</span> <span class="built_in">create-admin</span></span><br><span class="line"><span class="built_in">superset</span> <span class="string">load_examples</span></span><br><span class="line"><span class="string"></span><span class="comment"># 启动superset命令</span></span><br><span class="line"><span class="string">superset</span> <span class="string">run</span> -<span class="string">p</span> <span class="string">8088</span></span><br></pre></td></tr></table></figure>


<h4 id="基于pip安装"><a href="#基于pip安装" class="headerlink" title="基于pip安装"></a>基于pip安装</h4><p>参考<span class="exturl" data-url="aHR0cHM6Ly9zdXBlcnNldC5hcGFjaGUub3JnL2RvY3MvaW5zdGFsbGF0aW9uL2luc3RhbGxpbmctc3VwZXJzZXQtZnJvbS1zY3JhdGNo">https://superset.apache.org/docs/installation/installing-superset-from-scratch<i class="fa fa-external-link-alt"></i></span></p>
<p>遇到问题：</p>
<p>1） 安装client_driver时报错 OSError: mysql_config not found</p>
<p>解决：<span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjU0NTkzODYvbWFjLW9zLXgtZW52aXJvbm1lbnRlcnJvci1teXNxbC1jb25maWctbm90LWZvdW5k">https://stackoverflow.com/questions/25459386/mac-os-x-environmenterror-mysql-config-not-found<i class="fa fa-external-link-alt"></i></span></p>
<blockquote>
<p>Ok, well, first of all, let me check if I am on the same page as you:</p>
<ul>
<li>You installed python</li>
<li>You did <code>brew install mysql</code></li>
<li>You did <code>export PATH=$PATH:/usr/local/mysql/bin</code></li>
<li>And finally, you did <code>pip install MySQL-Python</code> (or <code>pip3 install mysqlclient</code> if using python 3)</li>
</ul>
</blockquote>
<h4 id="源码安装"><a href="#源码安装" class="headerlink" title="源码安装"></a>源码安装</h4><p>参考：<span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmVyaWM3LnNpdGUvMjAyMC8wMi8yMy9zdXBlcnNldC8=">https://blog.eric7.site/2020/02/23/superset/<i class="fa fa-external-link-alt"></i></span></p>
<p><strong>Anaconda 创建python环境</strong></p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">conda</span> create -n superset python=<span class="number">3</span>.<span class="number">7</span></span><br></pre></td></tr></table></figure>
<p>激活环境</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">conda <span class="built_in">activate</span> superset</span><br></pre></td></tr></table></figure>
<p><strong>github 下载源码包</strong></p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">git <span class="keyword">clone</span> <span class="title">https</span>://github.com/apache/incubator-superset.git</span><br><span class="line"></span><br><span class="line">git <span class="keyword">tag</span>　<span class="title">列出所有版本号</span></span><br><span class="line"><span class="title"></span></span><br><span class="line"><span class="title">#切换到自己想要的版本 </span></span><br><span class="line"><span class="title">git</span> checkout　+某版本号</span><br></pre></td></tr></table></figure>
<p>这里我是用资料较多的0.28版本</p>
<p><strong>安装扩展依赖</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#进入到目录</span><br><span class="line">cd incubator-superset</span><br><span class="line">pip install -r requirements.txt -i https:&#x2F;&#x2F;pypi.douban.com&#x2F;simple&#x2F;</span><br><span class="line"></span><br><span class="line">安装开发依赖</span><br><span class="line">pip install -r requirements-dev.txt -i https:&#x2F;&#x2F;pypi.douban.com&#x2F;simple&#x2F;</span><br></pre></td></tr></table></figure>
<p>这一步安装报错：</p>
<blockquote>
<p>版本问题报错</p>
<p>pandas, cryptography</p>
<p>对下面配置superset造成影响</p>
</blockquote>
<p><strong>安装superset</strong></p>
<figure class="highlight vala"><table><tr><td class="code"><pre><span class="line"><span class="meta">#incubator-superset 目录执行 pip install -e . </span></span><br></pre></td></tr></table></figure>
<p><strong>配置superset</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">创建管理员账户和密码</span><br><span class="line">这个命令已经不推荐使用了。</span><br><span class="line">fabmanager create-admin --app superset </span><br><span class="line">推荐使用</span><br><span class="line">$export FLASK_APP&#x3D;superset</span><br><span class="line">flask fab create-admin</span><br></pre></td></tr></table></figure>
<blockquote>
<p>报错：</p>
<p>1）</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><span class="line">ImportError: cannot <span class="keyword">import</span> name <span class="string">&#x27;_maybe_box_datetimelike&#x27;</span> <span class="keyword">from</span> <span class="string">&#x27;pandas.core.common&#x27;</span> (<span class="regexp">/Users/</span>joy<span class="regexp">/opt/</span>anaconda3<span class="regexp">/envs/</span>superset<span class="regexp">/lib/</span>python3.<span class="number">7</span><span class="regexp">/site-packages/</span>pandas<span class="regexp">/core/</span>common.py)</span><br></pre></td></tr></table></figure>

<p>要求pandas版本是0.23.1，安装的版本为1.2.4</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">(superset) ➜  incubator-superset <span class="attr">git:</span>(<span class="number">0.28</span>) pip show pandas</span><br><span class="line"><span class="attr">Name:</span> pandas</span><br><span class="line"><span class="attr">Version:</span> <span class="number">1.2</span><span class="number">.4</span></span><br><span class="line"><span class="attr">Summary:</span> Powerful data structures <span class="keyword">for</span> data analysis, time series, and statistics</span><br><span class="line">Home-<span class="attr">page:</span> <span class="attr">https:</span><span class="comment">//pandas.pydata.org</span></span><br><span class="line"><span class="attr">Author:</span> None</span><br><span class="line">Author-<span class="attr">email:</span> None</span><br><span class="line"><span class="attr">License:</span> BSD</span><br><span class="line"><span class="attr">Location:</span> <span class="regexp">/Users/</span>joy<span class="regexp">/opt/</span>anaconda3<span class="regexp">/envs/</span>superset<span class="regexp">/lib/</span>python3<span class="number">.7</span>/site-packages</span><br><span class="line"><span class="attr">Requires:</span> python-dateutil, pytz, numpy</span><br><span class="line">Required-<span class="attr">by:</span> superset</span><br></pre></td></tr></table></figure>

<p>尝试安装低版本pandas 要求的0.23.1在python3.7上build失败，</p>
<p>安装pandas==0.23.4  </p>
<p>安装后，superset upgrade 和init命令执行报错</p>
<p>2）</p>
<p>安装MarkupSafe==1.0时报错</p>
<p>解决：</p>
<p>pip install –upgrade pip setuptools==45.2.0</p>
<p>后重新运行</p>
<p><strong>其他版本问题基本可以解决，pypi可以下载到python36的安装包，然后自行pip install 安装包进行安装</strong></p>
</blockquote>
<hr>
<p>修改配置环境：</p>
<p>重新创建conda虚拟环境，superset版本从0.28为0.36</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">conda deactive</span><br><span class="line"><span class="comment"># 删除原有环境</span></span><br><span class="line">conda <span class="builtin-name">remove</span> -n superset --all</span><br><span class="line"><span class="comment"># 新建</span></span><br><span class="line">conda create -n superset <span class="attribute">python</span>=3.7</span><br><span class="line">conda activate superset</span><br><span class="line"></span><br><span class="line">git checkout 0.36</span><br><span class="line">……（后续安装步骤类似）</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：创建用户时有时可能因为用户邮箱等信息重复而创建失败</p>
</blockquote>
<p>还是不行，初始化superset时报错</p>
<blockquote>
<p>ERROR [root] Error: Can’t locate revision identified by ‘c878781977c6’</p>
</blockquote>
<hr>
<p>尝试直接安装最新版1.0.1（直接pip install -e .）</p>
<p>总算正常运行</p>
<p><strong>配置superset</strong></p>
<figure class="highlight vala"><table><tr><td class="code"><pre><span class="line"><span class="meta">#初始化数据库</span></span><br><span class="line">python superset db upgrade</span><br><span class="line"></span><br><span class="line"><span class="meta">#初始化角色和权限</span></span><br><span class="line">python superset init</span><br><span class="line"></span><br><span class="line"><span class="meta">#加载示例数据</span></span><br><span class="line">python superset load_examples</span><br></pre></td></tr></table></figure>
<p><strong>安装编译前端文件，并进入前端开发者模式</strong></p>
<ul>
<li><p>安装nodejs：解压，建立软连接</p>
<p>然后node -v 查看版本，查看正常即可</p>
</li>
<li><p>设置npm为淘宝镜像（原始地址：<span class="exturl" data-url="aHR0cHM6Ly9yZWdpc3RyeS5ucG1qcy5vcmcpLw==">https://registry.npmjs.org）<i class="fa fa-external-link-alt"></i></span></p>
<figure class="highlight arduino"><table><tr><td class="code"><pre><span class="line">npm <span class="built_in">config</span> <span class="built_in">set</span> registry https:<span class="comment">//registry.npm.taobao.org</span></span><br><span class="line">验证 `npm <span class="built_in">config</span> <span class="built_in">get</span> registry`</span><br></pre></td></tr></table></figure></li>
<li><p>进入superset/assets目录下（新版目录incubator-superset/superset-frontend/）,安装编译所需模块</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">npm <span class="keyword">install</span> -d</span><br></pre></td></tr></table></figure></li>
<li><p>编译前端文件，并进入前端开发者模式</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">npm <span class="builtin-name">run</span> build npm <span class="builtin-name">run</span> dev </span><br></pre></td></tr></table></figure>
<p>注：如果这两部编译失败，可能是因为nodejs版本过低。可尝试升级nodejs再试。</p>
<ul>
<li>运行完npm run dev，命令窗口会停止，不要误以为是执行不下去，保持窗口开启状态即可，一有文件变动时，它会重新编译</li>
</ul>
</li>
</ul>
<h4 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h4><ul>
<li><p>pip 方式安装好之后，clickhouse连接总是出问题：</p>
<ul>
<li>按照官网要求安装sqlalchemy-clickhouse后，test连接是出现 Error: Unexpected error occured</li>
<li>然后发现安装clickhouse-sqlalchemy之后可以解决连接问题，但是查询出来的数据没有表头</li>
</ul>
<p>终于在<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FwYWNoZS9zdXBlcnNldC9pc3N1ZXMvOTcxOSVFNiU4OSVCRSVFNSU4OCVCMCVFOCVBNyVBMyVFNSU4NiVCMyVFNSU4QSU5RSVFNiVCMyU5NSVFRiVCQyU5QQ==">https://github.com/apache/superset/issues/9719找到解决办法：<i class="fa fa-external-link-alt"></i></span></p>
<p>这位朋友和我的情况也一样</p>
<img data-src="../images/Superset%E4%B8%8A%E6%89%8B%E8%AE%B0%E5%BD%95/image-20210415104252896.png" alt="image-20210415104252896" style="zoom:80%;" />

<p>解决：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">pip</span> uninstall infi.clickhouse_orm</span><br><span class="line"><span class="attribute">pip</span> install infi.clickhouse_orm==<span class="number">1</span>.<span class="number">0</span>.<span class="number">4</span></span><br></pre></td></tr></table></figure>
<h2 id="Window-系统下安装完全解决"><a href="#Window-系统下安装完全解决" class="headerlink" title="Window 系统下安装完全解决"></a>Window 系统下安装完全解决</h2></li>
</ul>
<p>mac本出了点问题，转战工作电脑window系统</p>
<h4 id="pip方式快速安装"><a href="#pip方式快速安装" class="headerlink" title="pip方式快速安装"></a>pip方式快速安装</h4><ul>
<li><p>新建conda虚拟环境（主要为了降低试错成本，不影响其他环境）</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">conda</span> create -n superset(环境名) python=<span class="number">3</span>.<span class="number">7</span></span><br><span class="line"><span class="attribute">conda</span> activate superset</span><br></pre></td></tr></table></figure></li>
<li><p>虚拟环境中，安装superset</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">pip install apache-superset -i https:<span class="regexp">//</span>pypi.mirrors.ustc.edu.cn<span class="regexp">/simple/</span></span><br></pre></td></tr></table></figure>
<p>安装过程中可能出现的问题：</p>
<ul>
<li><p>提示需要Vitual c++ 14.0以上版本，个别依赖库编译失败，无法生成wheel：</p>
<p>解决：直接下载wheel，pip install wheel文件安装成功后，重新执行</p>
</li>
</ul>
</li>
<li><p>安装成功后配置</p>
<p>这一步之后很多博客要求进入superset/bin目录下执行python superset ……命令，可能由于版本问题，并不适用。之后步骤以此为准：</p>
<figure class="highlight dsconfig"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 初始化数据库</span></span><br><span class="line"><span class="string">superset</span> <span class="string">db</span> <span class="string">upgrade</span></span><br><span class="line"><span class="string"></span><span class="comment"># 创建管理员用户</span></span><br><span class="line"><span class="string">superset</span> <span class="string">fab</span> <span class="built_in">create-admin</span></span><br><span class="line"><span class="built_in">(fabmanager</span> <span class="built_in">create-admin</span> <span class="built_in">--app</span> <span class="string">superset</span> 命令会出现<span class="string">nontype</span> <span class="string">&quot;au_then&quot;</span>?（记不清了）报错)</span><br><span class="line"><span class="comment"># 初始化角色和权限</span></span><br><span class="line"><span class="string">superset</span> <span class="string">init</span></span><br></pre></td></tr></table></figure>
<h4 id="二次开发环境安装"><a href="#二次开发环境安装" class="headerlink" title="二次开发环境安装"></a>二次开发环境安装</h4></li>
</ul>
<p>pip安装仅适合使用，不适合二次开发。二次开发需要源码下载</p>
<ul>
<li><p>另外新建一份虚拟环境</p>
</li>
<li><p>从github上下载源码 </p>
<p><code>git clone https://github.com/apache/incubator-superset.git</code></p>
</li>
<li><p>安装 nodejs（这一步不需要在虚拟环境中），下载地址为 <span class="exturl" data-url="aHR0cHM6Ly9ub2RlanMub3JnL2Rpc3QvdjEyLjQuMC9ub2RlLXYxMi40LjAteDY0Lm1zaQ==">https://nodejs.org/dist/v12.4.0/node-v12.4.0-x64.msi<i class="fa fa-external-link-alt"></i></span></p>
<p>测试安装是否成功：<code>node -v</code>  <code>npm -v</code></p>
</li>
<li><p>（这一步不确定什么用）制作软连接（因为下载下来的源代码是superset\static\assets这个软连接可以在linux或者Mac上正常工作，但是在windows下不能正常工作）</p>
<p>删除G:\pyProduct\incubator-superset\superset\static\assets文件<br>输入代码(根据你下载代码的路径而定) </p>
<figure class="highlight taggerscript"><table><tr><td class="code"><pre><span class="line">mklink /D &quot;D:<span class="symbol">\i</span>ncubator-superset<span class="symbol">\s</span>uperset<span class="symbol">\s</span>tatic<span class="symbol">\a</span>ssets&quot; &quot;D:<span class="symbol">\i</span>ncubator-superset<span class="symbol">\s</span>uperset</span><br><span class="line">需要管理员模式运行</span><br></pre></td></tr></table></figure></li>
<li><p>安装。进入下载好的源码目录 <code>incubator-superset</code> 中</p>
<p><code>pip install -e .</code></p>
<p>(新版的superset最外层目录下已经没有requirement.txt了，直接安装就可以)</p>
<p>这一步出现的无法生成wheel文件问题解决同上</p>
</li>
<li><p>创建用户、初始化数据库、用户权限步骤类似</p>
</li>
<li><p>编译前端文件，进入superset-fronted 目录，<code>npm install -d</code></p>
<p>报错：</p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ERROR </span>in ./src/visualizations/TimeTable/TimeTable.jsx 101:10</span><br><span class="line">Module parse failed: Unexpected token (101:10)</span><br><span class="line">You may need an appropriate loader to handle this file type, currently no loader</span><br><span class="line">……</span><br></pre></td></tr></table></figure>
<p>解决：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FwYWNoZS9zdXBlcnNldC9pc3N1ZXMvMTA5OTc=">https://github.com/apache/superset/issues/10997<i class="fa fa-external-link-alt"></i></span></p>
<p>修改目录下 webpack.config.js 文件：</p>
<img data-src="../images/Superset%E4%B8%8A%E6%89%8B%E8%AE%B0%E5%BD%95/106452635-2493d300-64c3-11eb-9e7c-69c6d03bf426.png" alt="img" style="zoom:67%;" />

<p>成功！</p>
</li>
<li><p>进入前端开发者模式 <code>npm run dev</code></p>
</li>
<li><p>目录导入pycharm，配置好编译器就可以进行开发了</p>
</li>
</ul>
<h2 id="最终版解决方案"><a href="#最终版解决方案" class="headerlink" title="最终版解决方案"></a>最终版解决方案</h2><h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><p>python：3.7</p>
<p>superset：源码安装最新版1.1.0</p>
<h3 id="安装步骤"><a href="#安装步骤" class="headerlink" title="安装步骤"></a>安装步骤</h3><p>windows和mac系统亲测有效</p>
<h4 id="pip方式快速安装-1"><a href="#pip方式快速安装-1" class="headerlink" title="pip方式快速安装"></a>pip方式快速安装</h4><ul>
<li><p>新建conda虚拟环境（主要为了降低试错成本，不影响其他环境）</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">conda</span> create -n superset(环境名) python=<span class="number">3</span>.<span class="number">7</span></span><br><span class="line"><span class="attribute">conda</span> activate superset</span><br></pre></td></tr></table></figure></li>
<li><p>虚拟环境中，安装superset</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">pip install apache-superset -i https:<span class="regexp">//</span>pypi.mirrors.ustc.edu.cn<span class="regexp">/simple/</span></span><br></pre></td></tr></table></figure>
<p>安装过程中可能出现的问题：</p>
<ul>
<li><p>提示需要Vitual c++ 14.0以上版本，个别依赖库编译失败，无法生成wheel：</p>
<p>解决：直接下载wheel，pip install wheel文件安装成功后，重新执行</p>
</li>
</ul>
</li>
<li><p>安装成功后配置</p>
<p>这一步之后很多博客要求进入superset/bin目录下执行python superset ……命令，可能由于版本问题，并不适用。之后步骤以此为准：</p>
<figure class="highlight dsconfig"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 初始化数据库</span></span><br><span class="line"><span class="string">superset</span> <span class="string">db</span> <span class="string">upgrade</span></span><br><span class="line"><span class="string"></span><span class="comment"># 创建管理员用户</span></span><br><span class="line"><span class="string">superset</span> <span class="string">fab</span> <span class="built_in">create-admin</span></span><br><span class="line"><span class="built_in">(fabmanager</span> <span class="built_in">create-admin</span> <span class="built_in">--app</span> <span class="string">superset</span> 命令会出现<span class="string">nontype</span> <span class="string">&quot;au_then&quot;</span>?（记不清了）报错)</span><br><span class="line"><span class="comment"># 初始化角色和权限</span></span><br><span class="line"><span class="string">superset</span> <span class="string">init</span></span><br></pre></td></tr></table></figure>
<h4 id="二次开发环境安装-1"><a href="#二次开发环境安装-1" class="headerlink" title="二次开发环境安装"></a>二次开发环境安装</h4></li>
</ul>
<p>pip安装仅适合使用，不适合二次开发。二次开发需要源码下载</p>
<ul>
<li><p>另外新建一份虚拟环境</p>
</li>
<li><p>从github上下载源码 </p>
<p><code>git clone https://github.com/apache/incubator-superset.git</code></p>
</li>
<li><p>安装 nodejs（这一步不需要在虚拟环境中），下载地址为 <span class="exturl" data-url="aHR0cHM6Ly9ub2RlanMub3JnL2Rpc3QvdjEyLjQuMC9ub2RlLXYxMi40LjAteDY0Lm1zaQ==">https://nodejs.org/dist/v12.4.0/node-v12.4.0-x64.msi<i class="fa fa-external-link-alt"></i></span></p>
<p>测试安装是否成功：<code>node -v</code>  <code>npm -v</code></p>
</li>
<li><p>（这一步不确定什么用，mac 不需要）制作软连接（因为下载下来的源代码是superset\static\assets这个软连接可以在linux或者Mac上正常工作，但是在windows下不能正常工作）</p>
<p>删除G:\pyProduct\incubator-superset\superset\static\assets文件 输入代码(根据你下载代码的路径而定) </p>
<figure class="highlight taggerscript"><table><tr><td class="code"><pre><span class="line">mklink /D &quot;D:<span class="symbol">\i</span>ncubator-superset<span class="symbol">\s</span>uperset<span class="symbol">\s</span>tatic<span class="symbol">\a</span>ssets&quot; &quot;D:<span class="symbol">\i</span>ncubator-superset<span class="symbol">\s</span>uperset</span><br><span class="line">需要管理员模式运行</span><br></pre></td></tr></table></figure></li>
<li><p>安装。进入下载好的前端目录 <code>incubator-superset</code> 中</p>
<p><code>pip install -e .</code></p>
<p>(新版的superset最外层目录下已经没有requirement.txt了，直接安装就可以)</p>
<p>这一步出现的无法生成wheel文件问题解决同上</p>
</li>
<li><p>创建用户、初始化数据库、用户权限步骤类似</p>
</li>
<li><p>编译前端文件，进入superset-fronted 目录，<code>npm install -d</code></p>
<p>报错：</p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ERROR </span>in ./src/visualizations/TimeTable/TimeTable.jsx 101:10</span><br><span class="line">Module parse failed: Unexpected token (101:10)</span><br><span class="line">You may need an appropriate loader to handle this file type, currently no loader</span><br><span class="line">……</span><br></pre></td></tr></table></figure>
<p>解决：<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FwYWNoZS9zdXBlcnNldC9pc3N1ZXMvMTA5OTc=">https://github.com/apache/superset/issues/10997<i class="fa fa-external-link-alt"></i></span></p>
<p>修改目录下 webpack.config.js 文件：</p>
<p><img data-src="file:///Users/joy/MYBLOG/yinjiangyi.github.io/hexo/source/images/Superset%E4%B8%8A%E6%89%8B%E8%AE%B0%E5%BD%95/106452635-2493d300-64c3-11eb-9e7c-69c6d03bf426.png?lastModify=1626061918" alt="img"></p>
<p>成功！</p>
</li>
<li><p>进入前端开发者模式 <code>npm run dev</code></p>
</li>
<li><p>目录导入pycharm，配置好编译器就可以进行开发了</p>
</li>
</ul>
<h4 id="无网络环境下基于docker安装和Dashboard迁移"><a href="#无网络环境下基于docker安装和Dashboard迁移" class="headerlink" title="无网络环境下基于docker安装和Dashboard迁移"></a>无网络环境下基于docker安装和Dashboard迁移</h4><p>xj环境superset安装</p>
<p><strong>1）提前下载源码和docker镜像</strong></p>
<p>源码直接在github下载</p>
<p>需要提前下载的镜像：apache/superset, redis, node, post和postgress</p>
<figure class="highlight less"><table><tr><td class="code"><pre><span class="line"># 在有网络的机器上进行镜像拉取</span><br><span class="line"><span class="selector-tag">docker</span> <span class="selector-tag">pull</span> <span class="selector-tag">xxx</span>(镜像名)</span><br><span class="line"><span class="selector-tag">docker</span> <span class="selector-tag">save</span> <span class="selector-tag">-o</span> <span class="selector-tag">xxx</span><span class="selector-class">.tar</span>(要保存的压缩包名) <span class="selector-tag">xxx</span>(镜像名)</span><br></pre></td></tr></table></figure>
<p><strong>2）在目标机器上安装</strong></p>
<figure class="highlight vala"><table><tr><td class="code"><pre><span class="line"><span class="meta"># 将压缩包拷贝到目标机器上</span></span><br><span class="line">docker load -i xxx.tar(压缩包名)</span><br><span class="line"><span class="meta"># 在目标机器上的源码目录下运行，等待容器创建和运行</span></span><br><span class="line">docker-compose up</span><br><span class="line">或 docker-compose -f docker-compose.yml up</span><br></pre></td></tr></table></figure>




<h3 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h3><ul>
<li><p>安装client_driver时报错 OSError: mysql_config not found</p>
<p>解决：<span class="exturl" data-url="aHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjU0NTkzODYvbWFjLW9zLXgtZW52aXJvbm1lbnRlcnJvci1teXNxbC1jb25maWctbm90LWZvdW5k">https://stackoverflow.com/questions/25459386/mac-os-x-environmenterror-mysql-config-not-found<i class="fa fa-external-link-alt"></i></span></p>
<blockquote>
<p>Ok, well, first of all, let me check if I am on the same page as you:</p>
<ul>
<li>You installed python</li>
<li>You did <code>brew install mysql</code></li>
<li>You did <code>export PATH=$PATH:/usr/local/mysql/bin</code></li>
<li>And finally, you did <code>pip install MySQL-Python</code> (or <code>pip3 install mysqlclient</code> if using python 3)</li>
</ul>
</blockquote>
</li>
<li><p>pip 方式安装好之后，clickhouse连接总是出问题：</p>
<ul>
<li>按照官网要求安装sqlalchemy-clickhouse后，test连接是出现 Error: Unexpected error occured</li>
<li>然后发现安装clickhouse-sqlalchemy之后可以解决连接问题，但是查询出来的数据没有表头</li>
</ul>
<p>终于在<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FwYWNoZS9zdXBlcnNldC9pc3N1ZXMvOTcxOSVFNiU4OSVCRSVFNSU4OCVCMCVFOCVBNyVBMyVFNSU4NiVCMyVFNSU4QSU5RSVFNiVCMyU5NSVFRiVCQyU5QQ==">https://github.com/apache/superset/issues/9719找到解决办法：<i class="fa fa-external-link-alt"></i></span></p>
<p>这位朋友和我的情况也一样</p>
<p><img data-src="file:///Users/joy/MYBLOG/yinjiangyi.github.io/hexo/source/images/Superset%E4%B8%8A%E6%89%8B%E8%AE%B0%E5%BD%95/image-20210415104252896.png?lastModify=1626061918" alt="image-20210415104252896"></p>
<p>解决：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">pip</span> uninstall infi.clickhouse_orm</span><br><span class="line"><span class="attribute">pip</span> install infi.clickhouse_orm==<span class="number">1</span>.<span class="number">0</span>.<span class="number">4</span></span><br></pre></td></tr></table></figure></li>
<li><p>如果出现pip install 安装过程中build wheel失败，直接下载对应库的wheel包进行单独pip install 即可。</p>
</li>
</ul>
<h1 id="2-性能优化"><a href="#2-性能优化" class="headerlink" title="2. 性能优化"></a>2. 性能优化</h1><h3 id="Caching配置"><a href="#Caching配置" class="headerlink" title="Caching配置"></a>Caching配置</h3><p>官方文档：<span class="exturl" data-url="aHR0cHM6Ly9zdXBlcnNldC5hcGFjaGUub3JnL2RvY3MvaW5zdGFsbGF0aW9uL2NhY2hl">https://superset.apache.org/docs/installation/cache<i class="fa fa-external-link-alt"></i></span></p>
<p>参考：<span class="exturl" data-url="aHR0cHM6Ly95b3JrZS5naXRib29rcy5pby9zdXBlcnNldC1ub3RlL2NvbnRlbnQvY2hhcHRlcjEuaHRtbA==">https://yorke.gitbooks.io/superset-note/content/chapter1.html<i class="fa fa-external-link-alt"></i></span></p>
<h4 id="使用-Redis-做-Superset-的缓存"><a href="#使用-Redis-做-Superset-的缓存" class="headerlink" title="使用 Redis 做 Superset 的缓存"></a>使用 Redis 做 Superset 的缓存</h4><p>配置 Superset 的缓存后端，只需在其配置文件中提供一个 <code>CACHE_CONFIG</code> 常量即可。</p>
<p>而对于 Redis，我们还需要一个运行一个 Redis 服务，以及安装一个 redis-py 库（Redis 的 Python 接口）。</p>
<h5 id="安装-Redis"><a href="#安装-Redis" class="headerlink" title="安装 Redis"></a>安装 Redis</h5><p>当前 Redis 最新版为 3.2.8，在 <code>/opt/</code> 目录下安装并启动：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">cd <span class="regexp">/opt/</span></span><br><span class="line">wget http:<span class="regexp">//</span>download.redis.io<span class="regexp">/releases/</span>redis-<span class="number">3.2</span>.<span class="number">8</span>.tar.gz</span><br><span class="line">tar xzvf redis-<span class="number">3.2</span>.<span class="number">8</span>.tar.gz</span><br><span class="line">cd redis-<span class="number">3.2</span>.<span class="number">8</span>/</span><br><span class="line">make</span><br><span class="line">cd src/</span><br><span class="line">./redis-server</span><br></pre></td></tr></table></figure>
<p>make时报错：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">……</span><br><span class="line">server.c: 在函数‘hasActiveChildProcess’中:</span><br><span class="line">server.c:1476:1: 警告：在有返回值的函数中，控制流程到达函数尾 [-Wreturn-type]</span><br><span class="line"> &#125;</span><br><span class="line"> ^</span><br><span class="line">server.c: 在函数‘allPersistenceDisabled’中:</span><br><span class="line">server.c:1482:1: 警告：在有返回值的函数中，控制流程到达函数尾 [-Wreturn-type]</span><br><span class="line"> &#125;</span><br><span class="line"> ^</span><br><span class="line">server.c: 在函数‘writeCommandsDeniedByDiskError’中:</span><br><span class="line">server.c:3747:1: 警告：在有返回值的函数中，控制流程到达函数尾 [-Wreturn-type]</span><br><span class="line"> &#125;</span><br><span class="line"> ^</span><br><span class="line">server.c: 在函数‘iAmMaster’中:</span><br><span class="line">server.c:4914:1: 警告：在有返回值的函数中，控制流程到达函数尾 [-Wreturn-type]</span><br><span class="line"> &#125;</span><br><span class="line"> ^</span><br><span class="line">make[1]: *** [server.o] 错误 1</span><br><span class="line">make[1]: 离开目录“/opt/redis/redis-6.0.0/src”</span><br><span class="line">make: *** [all] 错误 2</span><br></pre></td></tr></table></figure>
<p> 解决： <span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80NTYyNzAzMS9hcnRpY2xlL2RldGFpbHMvMTA3MTY2ODY3P3V0bV9tZWRpdW09ZGlzdHJpYnV0ZS5wY19yZWxldmFudC5ub25lLXRhc2stYmxvZy1iYWlkdWpzX3RpdGxlLTAmYW1wO3NwbT0xMDAxLjIxMDEuMzAwMS40MjQy">https://blog.csdn.net/weixin_45627031/article/details/107166867?utm_medium=distribute.pc_relevant.none-task-blog-baidujs_title-0&amp;spm=1001.2101.3001.4242<i class="fa fa-external-link-alt"></i></span></p>
<p>升级gcc版本：</p>
<figure class="highlight autoit"><table><tr><td class="code"><pre><span class="line">[root<span class="symbol">@hadoop01</span> redis<span class="number">-6.0</span><span class="number">.5</span>]<span class="meta"># gcc -v                             # 查看gcc版本</span></span><br><span class="line">[root<span class="symbol">@hadoop01</span> redis<span class="number">-6.0</span><span class="number">.5</span>]<span class="meta"># yum -y install centos-release-scl  # 升级到9.1版本</span></span><br><span class="line">[root<span class="symbol">@hadoop01</span> redis<span class="number">-6.0</span><span class="number">.5</span>]<span class="meta"># yum -y install devtoolset-9-gcc devtoolset-9-gcc-c++ devtoolset-9-binutils</span></span><br><span class="line">[root<span class="symbol">@hadoop01</span> redis<span class="number">-6.0</span><span class="number">.5</span>]<span class="meta"># scl enable devtoolset-9 bash</span></span><br><span class="line">以上为临时启用，如果要长期使用gcc <span class="number">9.1</span>的话：</span><br><span class="line">[root<span class="symbol">@hadoop01</span> redis<span class="number">-6.0</span><span class="number">.5</span>]<span class="meta"># echo <span class="string">&quot;source /opt/rh/devtoolset-9/enable&quot;</span> &gt;&gt;/etc/profile</span></span><br></pre></td></tr></table></figure>
<h5 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h5><figure class="highlight accesslog"><table><tr><td class="code"><pre><span class="line">(superset) <span class="string">[root@bigdata-12 redis-6.0.0]</span># redis-cli</span><br><span class="line"><span class="number">127.0.0.1:6379</span>&gt;</span><br></pre></td></tr></table></figure>
<p>启动成功，查看进程</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">(superset) [root@bigdata-<span class="number">12</span> redis-<span class="number">6.0</span>.<span class="number">0</span>]<span class="comment"># ps -ef | grep redis</span></span><br><span class="line">root     <span class="number">17215</span> <span class="number">11601</span>  <span class="number">0</span> <span class="number">16</span>:<span class="number">14</span> pts<span class="regexp">/5    00:00:00 ./</span>src/redis-server *:<span class="number">6379</span> [cluster]</span><br></pre></td></tr></table></figure>
<p>这里主机号应该是*而不是127.0.0.1，否则外部机器无法连接redis服务。</p>
<p>如果为127.0.0.1，修改redis.conf文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">1&gt;</span><span class="bash">注释掉<span class="built_in">bind</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="built_in">bind</span> 127.0.0.1</span></span><br><span class="line"><span class="meta">2&gt;</span><span class="bash">默认不是守护进程方式运行，这里可以修改</span></span><br><span class="line">daemonize no</span><br><span class="line"><span class="meta">3&gt;</span><span class="bash">禁用保护模式</span></span><br><span class="line">protected-mode no</span><br></pre></td></tr></table></figure>
<p>启动Redis时指明配置文件</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="title">redis</span></span>-server ../redis.conf</span><br></pre></td></tr></table></figure>
<h5 id="安装-redis-py"><a href="#安装-redis-py" class="headerlink" title="安装 redis-py"></a>安装 redis-py</h5><p>在 Superset 所在虚拟环境中安装 redis-py：</p>
<figure class="highlight cmake"><table><tr><td class="code"><pre><span class="line">pip <span class="keyword">install</span> redis</span><br></pre></td></tr></table></figure>
<h5 id="配置使用-Redis-做缓存"><a href="#配置使用-Redis-做缓存" class="headerlink" title="配置使用 Redis 做缓存"></a>配置使用 Redis 做缓存</h5><p>在 Superset 的 config.py 中，做如下配置：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> redis</span><br><span class="line">...</span><br><span class="line">CACHE_DEFAULT_TIMEOUT = <span class="number">500</span> <span class="comment"># 默认超时时间</span></span><br><span class="line">CACHE_CONFIG = &#123;</span><br><span class="line">    <span class="string">&#x27;CACHE_TYPE&#x27;</span>: <span class="string">&#x27;redis&#x27;</span>, <span class="comment"># 使用 Redis</span></span><br><span class="line">    <span class="string">&#x27;CACHE_REDIS_HOST&#x27;</span>: <span class="string">&#x27;localhost&#x27;</span>, <span class="comment"># 配置域名</span></span><br><span class="line">    <span class="string">&#x27;CACHE_REDIS_PORT&#x27;</span>: <span class="number">6379</span>, <span class="comment"># 配置端口号</span></span><br><span class="line">    <span class="string">&#x27;CACHE_REDIS_URL&#x27;</span>: <span class="string">&#x27;redis://localhost:6379&#x27;</span> <span class="comment"># 配置 URL</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重新启动 Superset</p>
<p>打开任意 Dashboard，观察后台打印情况</p>
<p>配置成功！</p>
<h5 id="其他问题-1"><a href="#其他问题-1" class="headerlink" title="其他问题"></a>其他问题</h5>]]></content>
      <categories>
        <category>环境部署</category>
      </categories>
      <tags>
        <tag>superset</tag>
      </tags>
  </entry>
  <entry>
    <title>Git介绍及常用操作</title>
    <url>/2021/05/17/%E4%B8%8D%E5%AD%A6%E5%BA%9F%E4%B9%8B%E2%80%94%E2%80%94git%E7%AF%87/</url>
    <content><![CDATA[<p>Git 是用于 <span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS9MaW51eCVFNSU4NiU4NSVFNiVBMCVCOC8xMDE0MjgyMA==">Linux内核<i class="fa fa-external-link-alt"></i></span>开发的<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTclODklODglRTYlOUMlQUMlRTYlOEUlQTclRTUlODglQjY=">版本控制<i class="fa fa-external-link-alt"></i></span>工具。与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持（wingeddevil注：这得分是用什么样的服务端，使用http协议或者git协议等不太一样。并且在push和pull的时候和服务器端还是有交互的。），使<span class="exturl" data-url="aHR0cHM6Ly9iYWlrZS5iYWlkdS5jb20vaXRlbS8lRTYlQkElOTAlRTQlQkIlQTMlRTclQTAlODE=">源代码<i class="fa fa-external-link-alt"></i></span>的发布和交流极其方便。 Git 的速度很快，这对于诸如 Linux kernel 这样的大项目来说自然很重要。 Git 最为出色的是它的合并跟踪（merge tracing）能力。</p>
<a id="more"></a>

<h1 id="1-简介"><a href="#1-简介" class="headerlink" title="1 简介"></a>1 简介</h1><h3 id="GIT是什么"><a href="#GIT是什么" class="headerlink" title="GIT是什么"></a>GIT是什么</h3><p>git是目前世界上最先进的分布式版本控制系统。</p>
<p>接下来用通俗语言翻译下一下<strong>版本控制系统</strong>是用来干什么的。</p>
<p>举一个简单的例子，当你用word编辑一个重要的长文档时，会遇见两种让人头疼的情况：</p>
<p>第一个是文件经过多版本修改，为了备份编辑的版本数据，经常需要提前复制一份，时间久了，备份文件的名称已经无法让你清晰的回忆起具体的哪一版文件做了什么样的改动。</p>
<p>第二个是，当存在需要多人协作对同一个文件进行编辑的时候，修改处的合并非常麻烦，有时候会出现后修改的覆盖掉前面修改内容的情况，比如编辑confluence时就会发生这样的问题。</p>
<p>版本控制系统的出现就是为了解决这些问题。</p>
<p>而分布式作为git最主要的特征，使它相较于其他集中式版本控制系统，如svn等具有更明显的优势，因此git是目前使用范围最广的管理工具。</p>
<h3 id="GIT是怎么来的"><a href="#GIT是怎么来的" class="headerlink" title="GIT是怎么来的"></a>GIT是怎么来的</h3><p>Linux之父Linus创建了开源的linux，linux作为开源项目，它的壮大得益于全世界代码贡献者的参与。这么多人共同开发项目时是如何协作的？一开始（2002年以前），开发者将源代码文件通过diff方式发送给linus，由linus手动合并到linux代码中。</p>
<p>后来linus选择了一个商业版本控制系统BitKeeper，BitKeeper的东家BitMover公司出于人道主义精神，授权linux社区免费使用。但是05年，社区的开发者试图破解BitKeeper协议被BitMover公司发现了，于是公司要求收回系统的免费使用权。然后Linus花了<strong>两周时间</strong>用<strong>C语言</strong>开发了一个分布式版本控制系统Git，接下来的一个月内，Linux系统的代码完全由Git管理了。</p>
<h3 id="Git的强大之处"><a href="#Git的强大之处" class="headerlink" title="Git的强大之处"></a>Git的强大之处</h3><p>Git最大的特点就是<strong>分布式</strong>管理。</p>
<p>CVS和SVN都是集中式的版本控制系统，也就是说版本库是集中存放在中央服务器的，开发者需要先从中央服务器将文件拷贝回来，然后修改之后再把文件推送给中央服务器。所以必须要求有联网环境，并且如果哪天中央服务器挂掉了，文件就找不回来，安全性没有保障。</p>
<p>而分布式版本管理系统虽然也有一台充当中央服务器的电脑，但是他的作用其实是为了方便大家交换修改的内容（因为不是所有终端都在同一个局域网中）。每个人的电脑上都是一个完整的版本库，记录所有版本的改动情况，工作时不需要联网环境。</p>
<h1 id="2-安装"><a href="#2-安装" class="headerlink" title="2 安装"></a>2 安装</h1><p>最早Git是在Linux上开发的，很长一段时间内，Git也只能在Linux和Unix系统上跑。不过，慢慢地有人把它移植到了Windows上。现在，Git可以在Linux、Unix、Mac和Windows这几大平台上正常运行了。</p>
<p>要使用Git，第一步当然是安装Git了。根据你当前使用的平台来阅读下面的文字：</p>
<h3 id="在Linux上安装Git"><a href="#在Linux上安装Git" class="headerlink" title="在Linux上安装Git"></a>在Linux上安装Git</h3><p>首先，你可以试着输入<code>git</code>，看看系统有没有安装Git：</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><span class="line">$ git</span><br><span class="line">The program &#x27;git&#x27; <span class="keyword">is</span> currently <span class="keyword">not</span> installed. You can install <span class="keyword">it</span> <span class="keyword">by</span> typing:</span><br><span class="line">sudo apt-<span class="keyword">get</span> install git</span><br></pre></td></tr></table></figure>
<p>像上面的命令，有很多Linux会友好地告诉你Git没有安装，还会告诉你如何安装Git。</p>
<p>如果你碰巧用Debian或Ubuntu Linux，通过一条<code>sudo apt-get install git</code>就可以直接完成Git的安装，非常简单。</p>
<p>老一点的Debian或Ubuntu Linux，要把命令改为<code>sudo apt-get install git-core</code>，因为以前有个软件也叫GIT（GNU Interactive Tools），结果Git就只能叫<code>git-core</code>了。由于Git名气实在太大，后来就把GNU Interactive Tools改成<code>gnuit</code>，<code>git-core</code>正式改为<code>git</code>。</p>
<p>如果是其他Linux版本，可以直接通过源码安装。先从Git官网下载源码，然后解压，依次输入：<code>./config</code>，<code>make</code>，<code>sudo make install</code>这几个命令安装就好了。</p>
<h3 id="在Mac-OS-X上安装Git"><a href="#在Mac-OS-X上安装Git" class="headerlink" title="在Mac OS X上安装Git"></a>在Mac OS X上安装Git</h3><p>如果你正在使用Mac做开发，有两种安装Git的方法。</p>
<p>一是安装homebrew，然后通过homebrew安装Git，具体方法请参考homebrew的文档：<span class="exturl" data-url="aHR0cDovL2JyZXcuc2gvJUUzJTgwJTgy">http://brew.sh/。<i class="fa fa-external-link-alt"></i></span></p>
<p>第二种方法更简单，也是推荐的方法，就是直接从AppStore安装Xcode，Xcode集成了Git，不过默认没有安装，你需要运行Xcode，选择菜单“Xcode”-&gt;“Preferences”，在弹出窗口中找到“Downloads”，选择“Command Line Tools”，点“Install”就可以完成安装了。</p>
<p><img data-src="/images/%E4%B8%8D%E5%AD%A6%E5%BA%9F%E4%B9%8B%E2%80%94%E2%80%94git%E7%AF%87/0.jpeg" alt="install-git-by-xcode"></p>
<p>Xcode是Apple官方IDE，功能非常强大，是开发Mac和iOS App的必选装备，而且是免费的！</p>
<h3 id="在Windows上安装Git"><a href="#在Windows上安装Git" class="headerlink" title="在Windows上安装Git"></a>在Windows上安装Git</h3><p>在Windows上使用Git，可以从Git官网直接<span class="exturl" data-url="aHR0cHM6Ly9naXQtc2NtLmNvbS9kb3dubG9hZHM=">下载安装程序<i class="fa fa-external-link-alt"></i></span>，然后按默认选项安装即可。</p>
<p>安装完成后，在开始菜单里找到“Git”-&gt;“Git Bash”，蹦出一个类似命令行窗口的东西，就说明Git安装成功！</p>
<p><img data-src="/images/%E4%B8%8D%E5%AD%A6%E5%BA%9F%E4%B9%8B%E2%80%94%E2%80%94git%E7%AF%87/0-20210517152155022.jpeg" alt="install-git-on-windows"></p>
<p>安装完成后，还需要最后一步设置，在命令行输入：</p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">config</span> --<span class="keyword">global</span> user<span class="variable">.name</span> <span class="string">&quot;Your Name&quot;</span></span><br><span class="line">$ git <span class="keyword">config</span> --<span class="keyword">global</span> user<span class="variable">.email</span> <span class="string">&quot;email@example.com&quot;</span></span><br></pre></td></tr></table></figure>
<p>因为Git是分布式版本控制系统，所以，每个机器都必须自报家门：你的名字和Email地址。你也许会担心，如果有人故意冒充别人怎么办？这个不必担心，首先我们相信大家都是善良无知的群众，其次，真的有冒充的也是有办法可查的。</p>
<p>注意<code>git config</code>命令的<code>--global</code>参数，用了这个参数，表示你这台机器上所有的Git仓库都会使用这个配置，当然也可以对某个仓库指定不同的用户名和Email地址。</p>
<h1 id="3-创建版本库"><a href="#3-创建版本库" class="headerlink" title="3 创建版本库"></a>3 创建版本库</h1><p>什么是版本库呢？版本库又名仓库，英文名<strong>repository</strong>，你可以简单理解成一个目录，这个目录里面的所有文件都可以被Git管理起来，每个文件的修改、删除，Git都能跟踪，以便任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。</p>
<p>所以，创建一个版本库非常简单，<strong>首先，选择一个合适的地方，创建一个空目录</strong>：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> mkdir learngit</span><br><span class="line"><span class="variable">$</span> <span class="built_in">cd</span> learngit</span><br></pre></td></tr></table></figure>
<p>第二步，<strong>通过<code>git init</code>命令把这个目录变成Git可以管理的仓库：</strong></p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">$ git init</span><br><span class="line">Initialized empty Git repository <span class="keyword">in</span> <span class="regexp">/Users/mi</span>chael<span class="regexp">/learngit/</span>.git/</span><br></pre></td></tr></table></figure>
<p>瞬间Git就把仓库建好了，而且告诉你是一个空的仓库（empty Git repository），细心的读者可以发现当前<strong>目录下多了一个<code>.git</code>的目录</strong>，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。</p>
<p>如果你没有看到<code>.git</code>目录，那是因为这个目录默认是隐藏的，用<code>ls -ah</code>命令就可以看见。</p>
<p>也不一定必须在空目录下创建Git仓库，选择一个已经有东西的目录也是可以的。不过，不建议你使用自己正在开发的公司项目来学习Git，否则造成的一切后果概不负责。</p>
<h3 id="把文件添加到版本库"><a href="#把文件添加到版本库" class="headerlink" title="把文件添加到版本库"></a>把文件添加到版本库</h3><p>首先这里再明确一下，所有的版本控制系统，其实<strong>只能跟踪文本文件的改动</strong>，比如TXT文件，网页，所有的程序代码等等，Git也不例外。版本控制系统可以告诉你每次的改动，比如在第5行加了一个单词“Linux”，在第8行删了一个单词“Windows”。而<strong>图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，</strong>只能把二进制文件每次改动串起来，也就是只知道图片从100KB改成了120KB，但到底改了啥，版本控制系统不知道，也没法知道。</p>
<p>不幸的是，Microsoft的<strong>Word格式是二进制格式</strong>，因此，版本控制系统是没法跟踪Word文件的改动的，前面我们举的例子只是为了演示，如果要真正使用版本控制系统，就要以纯文本方式编写文件。</p>
<p>因为文本是有编码的，比如中文有常用的GBK编码，日文有Shift_JIS编码，如果没有历史遗留问题，强烈建议使用标准的UTF-8编码，所有语言使用同一种编码，既没有冲突，又被所有平台所支持。</p>
<p>使用Windows的童鞋要特别注意：</p>
<p>千万不要使用<strong>Windows自带的记事本编辑任何文本文件。原因是Microsoft开发记事本的团队使用了一个非常弱智的行为来保存UTF-8编码的文件，</strong>他们自作聪明地在每个文件开头添加了0xefbbbf（十六进制）的字符，你会遇到很多不可思议的问题，比如，网页第一行可能会显示一个“?”，明明正确的程序一编译就报语法错误，等等，都是由记事本的弱智行为带来的。建议你下载<span class="exturl" data-url="aHR0cDovL25vdGVwYWQtcGx1cy1wbHVzLm9yZy8=">Notepad++<i class="fa fa-external-link-alt"></i></span>代替记事本，不但功能强大，而且免费！记得把Notepad++的默认编码设置为UTF-8 without BOM即可：</p>
<p><img data-src="/images/%E4%B8%8D%E5%AD%A6%E5%BA%9F%E4%B9%8B%E2%80%94%E2%80%94git%E7%AF%87/0-20210517152819217.jpeg" alt="set-utf8-notepad++"></p>
<p>言归正传，现在我们编写一个<code>readme.txt</code>文件，内容如下：</p>
<figure class="highlight mercury"><table><tr><td class="code"><pre><span class="line">Git <span class="keyword">is</span> a version control system.</span><br><span class="line">Git <span class="keyword">is</span> free software.</span><br></pre></td></tr></table></figure>
<p>一定要放到<code>learngit</code>目录下（子目录也行），因为这是一个Git仓库，放到其他地方Git再厉害也找不到这个文件。</p>
<p>和把大象放到冰箱需要3步相比，把一个文件放到Git仓库只需要两步。</p>
<p>第一步，用命令<code>git add</code>告诉Git，把文件添加到仓库：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">add</span><span class="bash"> readme.txt</span></span><br></pre></td></tr></table></figure>
<p>执行上面的命令，没有任何显示，这就对了，Unix的哲学是“没有消息就是好消息”，说明添加成功。</p>
<p>第二步，用命令<code>git commit</code>告诉Git，把文件提交到仓库：</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">$ git commit -m <span class="string">&quot;wrote a readme file&quot;</span></span><br><span class="line">[<span class="keyword">master</span> <span class="title">(root-commit</span>) eaadf4e] wrote a readme file</span><br><span class="line"> <span class="number">1</span> file changed, <span class="number">2</span> insertions(+)</span><br><span class="line"> create mode <span class="number">100644</span> readme.txt</span><br></pre></td></tr></table></figure>
<p>简单解释一下<code>git commit</code>命令，<code>-m</code>后面输入的是本次提交的说明，可以输入任意内容，当然最好是有意义的，这样你就能从历史记录里方便地找到改动记录。</p>
<p>嫌麻烦不想输入<code>-m &quot;xxx&quot;</code>行不行？确实有办法可以这么干，但是强烈不建议你这么干，因为输入说明对自己对别人阅读都很重要。实在不想输入说明的童鞋请自行Google，我不告诉你这个参数。</p>
<p><code>git commit</code>命令执行成功后会告诉你，<code>1 file changed</code>：1个文件被改动（我们新添加的readme.txt文件）；<code>2 insertions</code>：插入了两行内容（readme.txt有两行内容）。</p>
<p><strong>为什么Git添加文件需要<code>add</code>，<code>commit</code>一共两步呢？因为<code>commit</code>可以一次提交很多文件，所以你可以多次<code>add</code>不同的文件，</strong>比如：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">add</span><span class="bash"> file1.txt</span></span><br><span class="line">$ git <span class="keyword">add</span><span class="bash"> file2.txt file3.txt</span></span><br><span class="line">$ git commit -m <span class="string">&quot;add 3 files.&quot;</span></span><br></pre></td></tr></table></figure>


<h1 id="4-时光穿梭机"><a href="#4-时光穿梭机" class="headerlink" title="4 时光穿梭机"></a>4 时光穿梭机</h1><p>我们已经成功地添加并提交了一个readme.txt文件，现在，是时候继续工作了，于是，我们继续修改readme.txt文件，改成如下内容：</p>
<figure class="highlight mercury"><table><tr><td class="code"><pre><span class="line">Git <span class="keyword">is</span> a distributed version control system.</span><br><span class="line">Git <span class="keyword">is</span> free software.</span><br></pre></td></tr></table></figure>
<p>现在，运行<code>git status</code>命令看看结果：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged <span class="keyword">for</span> commi<span class="variable">t:</span></span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> <span class="keyword">to</span> <span class="keyword">update</span> what will <span class="keyword">be</span> committed)</span><br><span class="line">  (use <span class="string">&quot;git checkout -- &lt;file&gt;...&quot;</span> <span class="keyword">to</span> discard <span class="keyword">changes</span> in working directory)</span><br><span class="line"></span><br><span class="line">	modified:   readme.txt</span><br><span class="line"></span><br><span class="line"><span class="keyword">no</span> <span class="keyword">changes</span> added <span class="keyword">to</span> commit (use <span class="string">&quot;git add&quot;</span> <span class="built_in">and</span>/<span class="built_in">or</span> <span class="string">&quot;git commit -a&quot;</span>)</span><br></pre></td></tr></table></figure>
<p><code>git status</code>命令可以让我们时刻掌握仓库当前的状态，上面的命令输出告诉我们，<code>readme.txt</code>被修改过了，但还没有准备提交的修改。</p>
<p>虽然Git告诉我们<code>readme.txt</code>被修改了，但如果能看看具体修改了什么内容，自然是很好的。比如你休假两周从国外回来，第一天上班时，已经记不清上次怎么修改的<code>readme.txt</code>，所以，需要用<code>git diff</code>这个命令看看：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">$ git diff readme.txt </span><br><span class="line"><span class="comment">diff --git a/readme.txt b/readme.txt</span></span><br><span class="line"><span class="comment">index 46d49bf..9247db6 100644</span></span><br><span class="line"><span class="comment">--- a/readme.txt</span></span><br><span class="line"><span class="comment">+++ b/readme.txt</span></span><br><span class="line"><span class="meta">@@ -1,2 +1,2 @@</span></span><br><span class="line"><span class="deletion">-Git is a version control system.</span></span><br><span class="line"><span class="addition">+Git is a distributed version control system.</span></span><br><span class="line"> Git is free software.</span><br></pre></td></tr></table></figure>
<p><code>git diff</code>顾名思义就是查看difference，显示的格式正是Unix通用的diff格式，可以从上面的命令输出看到，我们在第一行添加了一个<code>distributed</code>单词。</p>
<p>知道了对<code>readme.txt</code>作了什么修改后，再把它提交到仓库就放心多了，提交修改和提交新文件是一样的两步，第一步是<code>git add</code>：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">add</span><span class="bash"> readme.txt</span></span><br></pre></td></tr></table></figure>
<p>同样没有任何输出。在执行第二步<code>git commit</code>之前，我们再运行<code>git status</code>看看当前仓库的状态：</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line"><span class="keyword">On</span> branch master</span><br><span class="line">Changes <span class="keyword">to</span> be committed:</span><br><span class="line">  (<span class="keyword">use</span> <span class="string">&quot;git reset HEAD &lt;file&gt;...&quot;</span> <span class="keyword">to</span> unstage)</span><br><span class="line"></span><br><span class="line">	modified:   readme.txt</span><br></pre></td></tr></table></figure>
<p><code>git status</code>告诉我们，将要被提交的修改包括<code>readme.txt</code>，下一步，就可以放心地提交了：</p>
<figure class="highlight sas"><table><tr><td class="code"><pre><span class="line">$ git commit -m <span class="string">&quot;add distributed&quot;</span></span><br><span class="line">[master e475afc] <span class="meta">add</span> distributed</span><br><span class="line"> 1 <span class="meta">file</span> changed, 1 inserti<span class="meta">on(</span>+), 1 deleti<span class="meta">on(</span>-)</span><br></pre></td></tr></table></figure>
<p>提交后，我们再用<code>git status</code>命令看看仓库的当前状态：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line"><span class="keyword">On</span> branch master</span><br><span class="line"><span class="keyword">nothing</span> <span class="keyword">to</span> <span class="keyword">commit</span>, working tree clean</span><br></pre></td></tr></table></figure>
<p>Git告诉我们当前没有需要提交的修改，而且，工作目录是干净（working tree clean）的。</p>
<p><strong>小结</strong></p>
<ul>
<li>要随时掌握工作区的状态，使用<code>git status</code>命令。</li>
<li>如果<code>git status</code>告诉你有文件被修改过，用<code>git diff</code>可以查看修改内容。</li>
</ul>
<h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><p>现在，你已经学会了修改文件，然后把修改提交到Git版本库，现在，再练习一次，修改readme.txt文件如下：</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">Git is <span class="keyword">a</span> distributed <span class="built_in">version</span> control <span class="keyword">system</span>.</span><br><span class="line">Git is free software distributed under <span class="keyword">the</span> GPL.</span><br></pre></td></tr></table></figure>
<p>然后尝试提交：</p>
<figure class="highlight sas"><table><tr><td class="code"><pre><span class="line">$ git <span class="meta">add</span> readme.txt</span><br><span class="line">$ git commit -m <span class="string">&quot;append GPL&quot;</span></span><br><span class="line">[master 1094adb] append GPL</span><br><span class="line"> 1 <span class="meta">file</span> changed, 1 inserti<span class="meta">on(</span>+), 1 deleti<span class="meta">on(</span>-)</span><br></pre></td></tr></table></figure>
<p>像这样，你不断对文件进行修改，然后不断提交修改到版本库里，就好比玩RPG游戏时，每通过一关就会自动把游戏状态存盘，如果某一关没过去，你还可以选择读取前一关的状态。有些时候，在打Boss之前，你会手动存盘，以便万一打Boss失败了，可以从最近的地方重新开始。Git也是一样，每当你觉得文件修改到一定程度的时候，就可以“保存一个快照”，这个快照在Git中被称为<code>commit</code>。一旦你把文件改乱了，或者误删了文件，还可以从最近的一个<code>commit</code>恢复，然后继续工作，而不是把几个月的工作成果全部丢失。</p>
<p>现在，我们回顾一下<code>readme.txt</code>文件一共有几个版本被提交到Git仓库里了：</p>
<p>版本1：wrote a readme file</p>
<figure class="highlight mercury"><table><tr><td class="code"><pre><span class="line">Git <span class="keyword">is</span> a version control system.</span><br><span class="line">Git <span class="keyword">is</span> free software.</span><br></pre></td></tr></table></figure>
<p>版本2：add distributed</p>
<figure class="highlight mercury"><table><tr><td class="code"><pre><span class="line">Git <span class="keyword">is</span> a distributed version control system.</span><br><span class="line">Git <span class="keyword">is</span> free software.</span><br></pre></td></tr></table></figure>
<p>版本3：append GPL</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">Git is <span class="keyword">a</span> distributed <span class="built_in">version</span> control <span class="keyword">system</span>.</span><br><span class="line">Git is free software distributed under <span class="keyword">the</span> GPL.</span><br></pre></td></tr></table></figure>
<p>当然了，在实际工作中，我们脑子里怎么可能记得一个几千行的文件每次都改了什么内容，不然要版本控制系统干什么。版本控制系统肯定有某个命令可以告诉我们历史记录，在Git中，我们用<code>git log</code>命令查看：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">$ git log</span><br><span class="line">commit <span class="number">1094</span>adb<span class="number">7</span>b<span class="number">9</span>b<span class="number">3807259</span>d<span class="number">8</span>cb<span class="number">349e7</span>df<span class="number">1</span>d<span class="number">4</span>d<span class="number">6477073</span> (HEAD -&gt; master)</span><br><span class="line">Author: Michael Liao &lt;askxuefeng<span class="title">@gmail.com</span>&gt;</span><br><span class="line">Date:   Fri May <span class="number">18</span> <span class="number">21</span>:<span class="number">06</span>:<span class="number">15</span> <span class="number">2018</span> +<span class="number">0800</span></span><br><span class="line"></span><br><span class="line">    append GPL</span><br><span class="line"></span><br><span class="line">commit e<span class="number">475</span>afc<span class="number">93</span><span class="keyword">c</span><span class="number">209</span>a<span class="number">690</span><span class="keyword">c</span><span class="number">39</span><span class="keyword">c</span><span class="number">13</span>a<span class="number">46716e8</span>fa<span class="number">000</span><span class="keyword">c</span><span class="number">366</span></span><br><span class="line">Author: Michael Liao &lt;askxuefeng<span class="title">@gmail.com</span>&gt;</span><br><span class="line">Date:   Fri May <span class="number">18</span> <span class="number">21</span>:<span class="number">03</span>:<span class="number">36</span> <span class="number">2018</span> +<span class="number">0800</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">add</span> distributed</span><br><span class="line"></span><br><span class="line">commit eaadf<span class="number">4e385</span>e<span class="number">865</span>d<span class="number">25</span><span class="keyword">c</span><span class="number">48e7</span>ca<span class="number">9</span><span class="keyword">c</span><span class="number">8395</span><span class="keyword">c</span><span class="number">3</span>f<span class="number">7</span>dfaef<span class="number">0</span></span><br><span class="line">Author: Michael Liao &lt;askxuefeng<span class="title">@gmail.com</span>&gt;</span><br><span class="line">Date:   Fri May <span class="number">18</span> <span class="number">20</span>:<span class="number">59</span>:<span class="number">18</span> <span class="number">2018</span> +<span class="number">0800</span></span><br><span class="line"></span><br><span class="line">    wrote a readme file</span><br></pre></td></tr></table></figure>
<p><code>git log</code>命令显示从最近到最远的提交日志，我们可以看到3次提交，最近的一次是<code>append GPL</code>，上一次是<code>add distributed</code>，最早的一次是<code>wrote a readme file</code>。</p>
<p>如果嫌输出信息太多，看得眼花缭乱的，可以试试加上<code>--pretty=oneline</code>参数：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">$ git log --pretty<span class="operator">=</span>oneline</span><br><span class="line"><span class="number">1094</span>adb<span class="number">7</span>b<span class="number">9</span>b<span class="number">3807259</span>d<span class="number">8</span>cb<span class="number">349e7</span>df<span class="number">1</span>d<span class="number">4</span>d<span class="number">6477073</span> (HEAD -&gt; master) append GPL</span><br><span class="line">e<span class="number">475</span>afc<span class="number">93</span><span class="keyword">c</span><span class="number">209</span>a<span class="number">690</span><span class="keyword">c</span><span class="number">39</span><span class="keyword">c</span><span class="number">13</span>a<span class="number">46716e8</span>fa<span class="number">000</span><span class="keyword">c</span><span class="number">366</span> <span class="keyword">add</span> distributed</span><br><span class="line">eaadf<span class="number">4e385</span>e<span class="number">865</span>d<span class="number">25</span><span class="keyword">c</span><span class="number">48e7</span>ca<span class="number">9</span><span class="keyword">c</span><span class="number">8395</span><span class="keyword">c</span><span class="number">3</span>f<span class="number">7</span>dfaef<span class="number">0</span> wrote a readme file</span><br></pre></td></tr></table></figure>
<p>需要友情提示的是，你看到的一大串类似<code>1094adb...</code>的是<code>commit id</code>（版本号），和SVN不一样，Git的<code>commit id</code>不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示，而且你看到的<code>commit id</code>和我的肯定不一样，以你自己的为准。为什么<code>commit id</code>需要用这么一大串数字表示呢？因为Git是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。</p>
<p>每提交一个新版本，实际上Git就会把它们自动串成一条时间线。如果使用可视化工具查看Git历史，就可以更清楚地看到提交历史的时间线：</p>
<p><img data-src="/images/%E4%B8%8D%E5%AD%A6%E5%BA%9F%E4%B9%8B%E2%80%94%E2%80%94git%E7%AF%87/0-1395634.jpeg" alt="git-log-timeline"></p>
<p>好了，现在我们启动时光穿梭机，准备把<code>readme.txt</code>回退到上一个版本，也就是<code>add distributed</code>的那个版本，怎么做呢？</p>
<p>首先，Git必须知道当前版本是哪个版本，在Git中，用<code>HEAD</code>表示当前版本，也就是最新的提交<code>1094adb...</code>（注意我的提交ID和你的肯定不一样），上一个版本就是<code>HEAD^</code>，上上一个版本就是<code>HEAD^^</code>，当然往上100个版本写100个<code>^</code>比较容易数不过来，所以写成<code>HEAD~100</code>。</p>
<p>现在，我们要把当前版本<code>append GPL</code>回退到上一个版本<code>add distributed</code>，就可以使用<code>git reset</code>命令：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">reset</span> <span class="comment">--hard HEAD^</span></span><br><span class="line">HEAD <span class="keyword">is</span> now at e475afc <span class="keyword">add</span> distributed</span><br></pre></td></tr></table></figure>
<p><code>--hard</code>参数有啥意义？这个后面再讲，现在你先放心使用。</p>
<p>看看<code>readme.txt</code>的内容是不是版本<code>add distributed</code>：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">cat</span> readme.txt</span><br><span class="line">Git <span class="keyword">is</span> <span class="keyword">a</span> distributed <span class="keyword">version</span> control <span class="built_in">system</span>.</span><br><span class="line">Git <span class="keyword">is</span> free software.</span><br></pre></td></tr></table></figure>
<p>果然被还原了。</p>
<p>还可以继续回退到上一个版本<code>wrote a readme file</code>，不过且慢，让我们用<code>git log</code>再看看现在版本库的状态：</p>
<figure class="highlight llvm"><table><tr><td class="code"><pre><span class="line">$ git log</span><br><span class="line">commit e<span class="number">475</span>afc<span class="number">93</span><span class="keyword">c</span><span class="number">209</span>a<span class="number">690</span><span class="keyword">c</span><span class="number">39</span><span class="keyword">c</span><span class="number">13</span>a<span class="number">46716e8</span>fa<span class="number">000</span><span class="keyword">c</span><span class="number">366</span> (HEAD -&gt; master)</span><br><span class="line">Author: Michael Liao &lt;askxuefeng<span class="title">@gmail.com</span>&gt;</span><br><span class="line">Date:   Fri May <span class="number">18</span> <span class="number">21</span>:<span class="number">03</span>:<span class="number">36</span> <span class="number">2018</span> +<span class="number">0800</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">add</span> distributed</span><br><span class="line"></span><br><span class="line">commit eaadf<span class="number">4e385</span>e<span class="number">865</span>d<span class="number">25</span><span class="keyword">c</span><span class="number">48e7</span>ca<span class="number">9</span><span class="keyword">c</span><span class="number">8395</span><span class="keyword">c</span><span class="number">3</span>f<span class="number">7</span>dfaef<span class="number">0</span></span><br><span class="line">Author: Michael Liao &lt;askxuefeng<span class="title">@gmail.com</span>&gt;</span><br><span class="line">Date:   Fri May <span class="number">18</span> <span class="number">20</span>:<span class="number">59</span>:<span class="number">18</span> <span class="number">2018</span> +<span class="number">0800</span></span><br><span class="line"></span><br><span class="line">    wrote a readme file</span><br></pre></td></tr></table></figure>
<p>最新的那个版本<code>append GPL</code>已经看不到了！好比你从21世纪坐时光穿梭机来到了19世纪，想再回去已经回不去了，肿么办？</p>
<p>办法其实还是有的，只要上面的命令行窗口还没有被关掉，你就可以顺着往上找啊找啊，找到那个<code>append GPL</code>的<code>commit id</code>是<code>1094adb...</code>，于是就可以指定回到未来的某个版本：</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">reset</span> --hard 1094a</span><br><span class="line">HEAD <span class="built_in">is</span> now <span class="built_in">at</span> 83b0afe <span class="built_in">append</span> GPL</span><br></pre></td></tr></table></figure>
<p>版本号没必要写全，前几位就可以了，Git会自动去找。当然也不能只写前一两位，因为Git可能会找到多个版本号，就无法确定是哪一个了。</p>
<p>再小心翼翼地看看<code>readme.txt</code>的内容：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">cat</span> readme.txt</span><br><span class="line">Git <span class="keyword">is</span> <span class="keyword">a</span> distributed <span class="keyword">version</span> control <span class="built_in">system</span>.</span><br><span class="line">Git <span class="keyword">is</span> free software distributed under the GPL.</span><br></pre></td></tr></table></figure>
<p>果然，我胡汉三又回来了。</p>
<p>Git的版本回退速度非常快，因为Git在内部有个指向当前版本的<code>HEAD</code>指针，当你回退版本的时候，Git仅仅是把HEAD从指向<code>append GPL</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">┌────┐</span><br><span class="line">│HEAD│</span><br><span class="line">└────┘</span><br><span class="line">   │</span><br><span class="line">   └──&gt; ○ append GPL</span><br><span class="line">        │</span><br><span class="line">        ○ add distributed</span><br><span class="line">        │</span><br><span class="line">        ○ wrote a readme file</span><br></pre></td></tr></table></figure>
<p>改为指向<code>add distributed</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">┌────┐</span><br><span class="line">│HEAD│</span><br><span class="line">└────┘</span><br><span class="line">   │</span><br><span class="line">   │    ○ append GPL</span><br><span class="line">   │    │</span><br><span class="line">   └──&gt; ○ add distributed</span><br><span class="line">        │</span><br><span class="line">        ○ wrote a readme file</span><br></pre></td></tr></table></figure>
<p>然后顺便把工作区的文件更新了。所以你让<code>HEAD</code>指向哪个版本号，你就把当前版本定位在哪。</p>
<p>现在，你回退到了某个版本，关掉了电脑，第二天早上就后悔了，想恢复到新版本怎么办？找不到新版本的<code>commit id</code>怎么办？</p>
<p>在Git中，总是有后悔药可以吃的。当你用<code>$ git reset --hard HEAD^</code>回退到<code>add distributed</code>版本时，再想恢复到<code>append GPL</code>，就必须找到<code>append GPL</code>的commit id。Git提供了一个命令<code>git reflog</code>用来记录你的每一次命令：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ git reflog</span><br><span class="line">e475afc HEAD@&#123;<span class="number">1</span>&#125;: rese<span class="variable">t:</span> moving <span class="keyword">to</span> HEAD^</span><br><span class="line"><span class="number">1094</span>adb (HEAD -&gt; master) HEAD@&#123;<span class="number">2</span>&#125;: commi<span class="variable">t:</span> <span class="keyword">append</span> GPL</span><br><span class="line">e475afc HEAD@&#123;<span class="number">3</span>&#125;: commi<span class="variable">t:</span> <span class="built_in">add</span> distributed</span><br><span class="line">eaadf4e HEAD@&#123;<span class="number">4</span>&#125;: commit (initial): wrote <span class="keyword">a</span> readme <span class="keyword">file</span></span><br></pre></td></tr></table></figure>
<p>终于舒了口气，从输出可知，<code>append GPL</code>的commit id是<code>1094adb</code>，现在，你又可以乘坐时光机回到未来了。</p>
<p><strong>小结</strong></p>
<p>现在总结一下：</p>
<ul>
<li><code>HEAD</code>指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令<code>git reset --hard commit_id</code>。</li>
<li>穿梭前，用<code>git log</code>可以查看提交历史，以便确定要回退到哪个版本。</li>
<li>要重返未来，用<code>git reflog</code>查看命令历史，以便确定要回到未来的哪个版本。</li>
</ul>
<h3 id="工作区和暂存区"><a href="#工作区和暂存区" class="headerlink" title="工作区和暂存区"></a>工作区和暂存区</h3><p>Git和其他版本控制系统如SVN的一个不同之处就是有暂存区的概念。</p>
<p>先来看名词解释。</p>
<h4 id="工作区（Working-Directory）"><a href="#工作区（Working-Directory）" class="headerlink" title="工作区（Working Directory）"></a>工作区（Working Directory）</h4><p>就是你在电脑里能看到的目录，比如我的<code>learngit</code>文件夹就是一个工作区：</p>
<p><img data-src="/images/%E4%B8%8D%E5%AD%A6%E5%BA%9F%E4%B9%8B%E2%80%94%E2%80%94git%E7%AF%87/0.png" alt="working-dir"></p>
<h4 id="版本库（Repository）"><a href="#版本库（Repository）" class="headerlink" title="版本库（Repository）"></a>版本库（Repository）</h4><p>工作区有一个隐藏目录<code>.git</code>，这个不算工作区，而是Git的版本库。</p>
<p>Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支<code>master</code>，以及指向<code>master</code>的一个指针叫<code>HEAD</code>。</p>
<p><img data-src="/images/%E4%B8%8D%E5%AD%A6%E5%BA%9F%E4%B9%8B%E2%80%94%E2%80%94git%E7%AF%87/0-20210519114125658.jpeg" alt="git-repo"></p>
<p>分支和<code>HEAD</code>的概念我们以后再讲。</p>
<p>前面讲了我们把文件往Git版本库里添加的时候，是分两步执行的：</p>
<p>第一步是用<code>git add</code>把文件添加进去，实际上就是把文件修改添加到暂存区；</p>
<p>第二步是用<code>git commit</code>提交更改，实际上就是把暂存区的所有内容提交到当前分支。</p>
<p>因为我们创建Git版本库时，Git自动为我们创建了唯一一个<code>master</code>分支，所以，现在，<code>git commit</code>就是往<code>master</code>分支上提交更改。</p>
<p>你可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。</p>
<p>俗话说，实践出真知。现在，我们再练习一遍，先对<code>readme.txt</code>做个修改，比如加上一行内容：</p>
<figure class="highlight mercury"><table><tr><td class="code"><pre><span class="line">Git <span class="keyword">is</span> a distributed version control system.</span><br><span class="line">Git <span class="keyword">is</span> free software distributed under the GPL.</span><br><span class="line">Git has a <span class="keyword">mutable</span> index called stage.</span><br></pre></td></tr></table></figure>
<p>然后，在工作区新增一个<code>LICENSE</code>文本文件（内容随便写）。</p>
<p>先用<code>git status</code>查看一下状态：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged <span class="keyword">for</span> commi<span class="variable">t:</span></span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> <span class="keyword">to</span> <span class="keyword">update</span> what will <span class="keyword">be</span> committed)</span><br><span class="line">  (use <span class="string">&quot;git checkout -- &lt;file&gt;...&quot;</span> <span class="keyword">to</span> discard <span class="keyword">changes</span> in working directory)</span><br><span class="line"></span><br><span class="line">	modified:   readme.txt</span><br><span class="line"></span><br><span class="line">Untracked <span class="keyword">file</span><span class="variable">s:</span></span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> <span class="keyword">to</span> include in what will <span class="keyword">be</span> committed)</span><br><span class="line"></span><br><span class="line">	LICENSE</span><br><span class="line"></span><br><span class="line"><span class="keyword">no</span> <span class="keyword">changes</span> added <span class="keyword">to</span> commit (use <span class="string">&quot;git add&quot;</span> <span class="built_in">and</span>/<span class="built_in">or</span> <span class="string">&quot;git commit -a&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>Git非常清楚地告诉我们，<code>readme.txt</code>被修改了，而<code>LICENSE</code>还从来没有被添加过，所以它的状态是<code>Untracked</code>。</p>
<p>现在，使用两次命令<code>git add</code>，把<code>readme.txt</code>和<code>LICENSE</code>都添加后，用<code>git status</code>再查看一下：</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line"><span class="keyword">On</span> branch master</span><br><span class="line">Changes <span class="keyword">to</span> be committed:</span><br><span class="line">  (<span class="keyword">use</span> <span class="string">&quot;git reset HEAD &lt;file&gt;...&quot;</span> <span class="keyword">to</span> unstage)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">new</span> <span class="keyword">file</span>:   LICENSE</span><br><span class="line">	modified:   readme.txt</span><br></pre></td></tr></table></figure>
<p>现在，暂存区的状态就变成这样了：</p>
<p><img data-src="/images/%E4%B8%8D%E5%AD%A6%E5%BA%9F%E4%B9%8B%E2%80%94%E2%80%94git%E7%AF%87/0-20210519114125893.jpeg" alt="git-stage"></p>
<p>所以，<code>git add</code>命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行<code>git commit</code>就可以一次性把暂存区的所有修改提交到分支。</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">$ git commit -m <span class="string">&quot;understand how stage works&quot;</span></span><br><span class="line">[<span class="keyword">master</span> <span class="title">e43a48b</span>] understand how stage works</span><br><span class="line"> <span class="number">2</span> files changed, <span class="number">2</span> insertions(+)</span><br><span class="line"> create mode <span class="number">100644</span> LICENSE</span><br></pre></td></tr></table></figure>
<p>一旦提交后，如果你又没有对工作区做任何修改，那么工作区就是“干净”的：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line"><span class="keyword">On</span> branch master</span><br><span class="line"><span class="keyword">nothing</span> <span class="keyword">to</span> <span class="keyword">commit</span>, working tree clean</span><br></pre></td></tr></table></figure>
<p>现在版本库变成了这样，暂存区就没有任何内容了：</p>
<p><img data-src="/images/%E4%B8%8D%E5%AD%A6%E5%BA%9F%E4%B9%8B%E2%80%94%E2%80%94git%E7%AF%87/0-20210519114125641.jpeg" alt="git-stage-after-commit"></p>
<p><strong>小结</strong></p>
<p>暂存区是Git非常重要的概念，弄明白了暂存区，就弄明白了Git的很多操作到底干了什么。</p>
<p>没弄明白暂存区是怎么回事的童鞋，请向上滚动页面，再看一次。</p>
<h3 id="管理修改"><a href="#管理修改" class="headerlink" title="管理修改"></a>管理修改</h3><p>现在，假定你已经完全掌握了暂存区的概念。下面，我们要讨论的就是，为什么Git比其他版本控制系统设计得优秀，因为Git跟踪并管理的是修改，而非文件。</p>
<p>你会问，什么是修改？比如你新增了一行，这就是一个修改，删除了一行，也是一个修改，更改了某些字符，也是一个修改，删了一些又加了一些，也是一个修改，甚至创建一个新文件，也算一个修改。</p>
<p>为什么说Git管理的是修改，而不是文件呢？我们还是做实验。第一步，对readme.txt做一个修改，比如加一行内容：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">cat</span> readme.txt</span><br><span class="line">Git <span class="keyword">is</span> <span class="keyword">a</span> distributed <span class="keyword">version</span> control <span class="built_in">system</span>.</span><br><span class="line">Git <span class="keyword">is</span> free software distributed under the GPL.</span><br><span class="line">Git <span class="built_in">has</span> <span class="keyword">a</span> mutable <span class="built_in">index</span> called stage.</span><br><span class="line">Git tracks <span class="keyword">changes</span>.</span><br></pre></td></tr></table></figure>
<p>然后，添加：</p>
<figure class="highlight vala"><table><tr><td class="code"><pre><span class="line">$ git add readme.txt</span><br><span class="line">$ git status</span><br><span class="line"><span class="meta"># On branch master</span></span><br><span class="line"><span class="meta"># Changes to be committed:</span></span><br><span class="line"><span class="meta">#   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="meta">#       modified:   readme.txt</span></span><br><span class="line"><span class="meta">#</span></span><br></pre></td></tr></table></figure>
<p>然后，再修改readme.txt：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">cat</span> readme.txt </span><br><span class="line">Git <span class="keyword">is</span> <span class="keyword">a</span> distributed <span class="keyword">version</span> control <span class="built_in">system</span>.</span><br><span class="line">Git <span class="keyword">is</span> free software distributed under the GPL.</span><br><span class="line">Git <span class="built_in">has</span> <span class="keyword">a</span> mutable <span class="built_in">index</span> called stage.</span><br><span class="line">Git tracks <span class="keyword">changes</span> of <span class="keyword">files</span>.</span><br></pre></td></tr></table></figure>
<p>提交：</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">$ git commit -m <span class="string">&quot;git tracks changes&quot;</span></span><br><span class="line">[<span class="keyword">master</span> <span class="title">519219b</span>] git tracks changes</span><br><span class="line"> <span class="number">1</span> file changed, <span class="number">1</span> insertion(+)</span><br></pre></td></tr></table></figure>
<p>提交后，再看看状态：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged <span class="keyword">for</span> commi<span class="variable">t:</span></span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> <span class="keyword">to</span> <span class="keyword">update</span> what will <span class="keyword">be</span> committed)</span><br><span class="line">  (use <span class="string">&quot;git checkout -- &lt;file&gt;...&quot;</span> <span class="keyword">to</span> discard <span class="keyword">changes</span> in working directory)</span><br><span class="line"></span><br><span class="line">	modified:   readme.txt</span><br><span class="line"></span><br><span class="line"><span class="keyword">no</span> <span class="keyword">changes</span> added <span class="keyword">to</span> commit (use <span class="string">&quot;git add&quot;</span> <span class="built_in">and</span>/<span class="built_in">or</span> <span class="string">&quot;git commit -a&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>咦，怎么第二次的修改没有被提交？</p>
<p>别激动，我们回顾一下操作过程：</p>
<p>第一次修改 -&gt; <code>git add</code> -&gt; 第二次修改 -&gt; <code>git commit</code></p>
<p>你看，我们前面讲了，Git管理的是修改，当你用<code>git add</code>命令后，在工作区的第一次修改被放入暂存区，准备提交，但是，在工作区的第二次修改并没有放入暂存区，所以，<code>git commit</code>只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。</p>
<p>提交后，用<code>git diff HEAD -- readme.txt</code>命令可以查看工作区和版本库里面最新版本的区别：</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line">$ git diff HEAD -- readme.txt </span><br><span class="line"><span class="comment">diff --git a/readme.txt b/readme.txt</span></span><br><span class="line"><span class="comment">index 76d770f..a9c5755 100644</span></span><br><span class="line"><span class="comment">--- a/readme.txt</span></span><br><span class="line"><span class="comment">+++ b/readme.txt</span></span><br><span class="line"><span class="meta">@@ -1,4 +1,4 @@</span></span><br><span class="line"> Git is a distributed version control system.</span><br><span class="line"> Git is free software distributed under the GPL.</span><br><span class="line"> Git has a mutable index called stage.</span><br><span class="line"><span class="deletion">-Git tracks changes.</span></span><br><span class="line"><span class="addition">+Git tracks changes of files.</span></span><br></pre></td></tr></table></figure>
<p>可见，第二次修改确实没有被提交。</p>
<p>那怎么提交第二次修改呢？你可以继续<code>git add</code>再<code>git commit</code>，也可以别着急提交第一次修改，先<code>git add</code>第二次修改，再<code>git commit</code>，就相当于把两次修改合并后一块提交了：</p>
<p>第一次修改 -&gt; <code>git add</code> -&gt; 第二次修改 -&gt; <code>git add</code> -&gt; <code>git commit</code></p>
<p>好，现在，把第二次修改提交了，然后开始小结。</p>
<p><strong>小结</strong></p>
<p>现在，你又理解了Git是如何跟踪修改的，每次修改，如果不用<code>git add</code>到暂存区，那就不会加入到<code>commit</code>中。</p>
<h3 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h3><p>自然，你是不会犯错的。不过现在是凌晨两点，你正在赶一份工作报告，你在<code>readme.txt</code>中添加了一行：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">cat</span> readme.txt</span><br><span class="line">Git <span class="keyword">is</span> <span class="keyword">a</span> distributed <span class="keyword">version</span> control <span class="built_in">system</span>.</span><br><span class="line">Git <span class="keyword">is</span> free software distributed under the GPL.</span><br><span class="line">Git <span class="built_in">has</span> <span class="keyword">a</span> mutable <span class="built_in">index</span> called stage.</span><br><span class="line">Git tracks <span class="keyword">changes</span> of <span class="keyword">files</span>.</span><br><span class="line">My stupid boss still prefers SVN.</span><br></pre></td></tr></table></figure>
<p>在你准备提交前，一杯咖啡起了作用，你猛然发现了<code>stupid boss</code>可能会让你丢掉这个月的奖金！</p>
<p>既然错误发现得很及时，就可以很容易地纠正它。你可以删掉最后一行，手动把文件恢复到上一个版本的状态。如果用<code>git status</code>查看一下：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged <span class="keyword">for</span> commi<span class="variable">t:</span></span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> <span class="keyword">to</span> <span class="keyword">update</span> what will <span class="keyword">be</span> committed)</span><br><span class="line">  (use <span class="string">&quot;git checkout -- &lt;file&gt;...&quot;</span> <span class="keyword">to</span> discard <span class="keyword">changes</span> in working directory)</span><br><span class="line"></span><br><span class="line">	modified:   readme.txt</span><br><span class="line"></span><br><span class="line"><span class="keyword">no</span> <span class="keyword">changes</span> added <span class="keyword">to</span> commit (use <span class="string">&quot;git add&quot;</span> <span class="built_in">and</span>/<span class="built_in">or</span> <span class="string">&quot;git commit -a&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>你可以发现，Git会告诉你，<code>git checkout -- file</code>可以丢弃工作区的修改：</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">$ git checkout <span class="comment">-- readme.txt</span></span><br></pre></td></tr></table></figure>
<p>命令<code>git checkout -- readme.txt</code>意思就是，把<code>readme.txt</code>文件在工作区的修改全部撤销，这里有两种情况：</p>
<p>一种是<code>readme.txt</code>自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p>
<p>一种是<code>readme.txt</code>已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p>
<p>总之，就是让这个文件回到最近一次<code>git commit</code>或<code>git add</code>时的状态。</p>
<p>现在，看看<code>readme.txt</code>的文件内容：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">cat</span> readme.txt</span><br><span class="line">Git <span class="keyword">is</span> <span class="keyword">a</span> distributed <span class="keyword">version</span> control <span class="built_in">system</span>.</span><br><span class="line">Git <span class="keyword">is</span> free software distributed under the GPL.</span><br><span class="line">Git <span class="built_in">has</span> <span class="keyword">a</span> mutable <span class="built_in">index</span> called stage.</span><br><span class="line">Git tracks <span class="keyword">changes</span> of <span class="keyword">files</span>.</span><br></pre></td></tr></table></figure>
<p>文件内容果然复原了。</p>
<p><code>git checkout -- file</code>命令中的<code>--</code>很重要，没有<code>--</code>，就变成了“切换到另一个分支”的命令，我们在后面的分支管理中会再次遇到<code>git checkout</code>命令。</p>
<p>现在假定是凌晨3点，你不但写了一些胡话，还<code>git add</code>到暂存区了：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ <span class="keyword">cat</span> readme.txt</span><br><span class="line">Git <span class="keyword">is</span> <span class="keyword">a</span> distributed <span class="keyword">version</span> control <span class="built_in">system</span>.</span><br><span class="line">Git <span class="keyword">is</span> free software distributed under the GPL.</span><br><span class="line">Git <span class="built_in">has</span> <span class="keyword">a</span> mutable <span class="built_in">index</span> called stage.</span><br><span class="line">Git tracks <span class="keyword">changes</span> of <span class="keyword">files</span>.</span><br><span class="line">My stupid boss still prefers SVN.</span><br><span class="line"></span><br><span class="line">$ git <span class="built_in">add</span> readme.txt</span><br></pre></td></tr></table></figure>
<p>庆幸的是，在<code>commit</code>之前，你发现了这个问题。用<code>git status</code>查看一下，修改只是添加到了暂存区，还没有提交：</p>
<figure class="highlight vhdl"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line"><span class="keyword">On</span> branch master</span><br><span class="line">Changes <span class="keyword">to</span> be committed:</span><br><span class="line">  (<span class="keyword">use</span> <span class="string">&quot;git reset HEAD &lt;file&gt;...&quot;</span> <span class="keyword">to</span> unstage)</span><br><span class="line"></span><br><span class="line">	modified:   readme.txt</span><br></pre></td></tr></table></figure>
<p>Git同样告诉我们，用命令<code>git reset HEAD &lt;file&gt;</code>可以把暂存区的修改撤销掉（unstage），重新放回工作区：</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">reset</span> HEAD readme.txt</span><br><span class="line">Unstaged changes after <span class="built_in">reset</span>:</span><br><span class="line">M	readme.txt</span><br></pre></td></tr></table></figure>
<p><code>git reset</code>命令既可以回退版本，也可以把暂存区的修改回退到工作区。当我们用<code>HEAD</code>时，表示最新的版本。</p>
<p>再用<code>git status</code>查看一下，现在暂存区是干净的，工作区有修改：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged <span class="keyword">for</span> commi<span class="variable">t:</span></span><br><span class="line">  (use <span class="string">&quot;git add &lt;file&gt;...&quot;</span> <span class="keyword">to</span> <span class="keyword">update</span> what will <span class="keyword">be</span> committed)</span><br><span class="line">  (use <span class="string">&quot;git checkout -- &lt;file&gt;...&quot;</span> <span class="keyword">to</span> discard <span class="keyword">changes</span> in working directory)</span><br><span class="line"></span><br><span class="line">	modified:   readme.txt</span><br></pre></td></tr></table></figure>
<p>还记得如何丢弃工作区的修改吗？</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">$ git checkout <span class="comment">-- readme.txt</span></span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line"><span class="keyword">On</span> branch master</span><br><span class="line"><span class="keyword">nothing</span> <span class="keyword">to</span> <span class="keyword">commit</span>, working tree clean</span><br></pre></td></tr></table></figure>
<p>整个世界终于清静了！</p>
<p>现在，假设你不但改错了东西，还从暂存区提交到了版本库，怎么办呢？还记得<span class="exturl" data-url="aHR0cHM6Ly93d3cubGlhb3h1ZWZlbmcuY29tL3dpa2kvODk2MDQzNDg4MDI5NjAwLzg5NzAxMzU3MzUxMjE5Mg==">版本回退<i class="fa fa-external-link-alt"></i></span>一节吗？可以回退到上一个版本。不过，这是有条件的，就是你还没有把自己的本地版本库推送到远程。还记得Git是分布式版本控制系统吗？我们后面会讲到远程版本库，一旦你把<code>stupid boss</code>提交推送到远程版本库，你就真的惨了……</p>
<p><strong>小结</strong></p>
<p>又到了小结时间。</p>
<p>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code>。</p>
<p>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD &lt;file&gt;</code>，就回到了场景1，第二步按场景1操作。</p>
<p>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考<span class="exturl" data-url="aHR0cHM6Ly93d3cubGlhb3h1ZWZlbmcuY29tL3dpa2kvODk2MDQzNDg4MDI5NjAwLzg5NzAxMzU3MzUxMjE5Mg==">版本回退<i class="fa fa-external-link-alt"></i></span>一节，不过前提是没有推送到远程库。</p>
<h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><p>在Git中，删除也是一个修改操作，我们实战一下，先添加一个新文件<code>test.txt</code>到Git并且提交：</p>
<figure class="highlight sas"><table><tr><td class="code"><pre><span class="line">$ git <span class="meta">add</span> test.txt</span><br><span class="line"></span><br><span class="line">$ git commit -m <span class="string">&quot;add test.txt&quot;</span></span><br><span class="line">[master b84166e] <span class="meta">add</span> test.txt</span><br><span class="line"> 1 <span class="meta">file</span> changed, 1 inserti<span class="meta">on(</span>+)</span><br><span class="line"> <span class="meta">create</span> mode 100644 test.txt</span><br></pre></td></tr></table></figure>
<p>一般情况下，你通常直接在文件管理器中把没用的文件删了，或者用<code>rm</code>命令删了：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> <span class="built_in">rm</span> test.txt</span><br></pre></td></tr></table></figure>
<p>这个时候，Git知道你删除了文件，因此，工作区和版本库就不一致了，<code>git status</code>命令会立刻告诉你哪些文件被删除了：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged <span class="keyword">for</span> commi<span class="variable">t:</span></span><br><span class="line">  (use <span class="string">&quot;git add/rm &lt;file&gt;...&quot;</span> <span class="keyword">to</span> <span class="keyword">update</span> what will <span class="keyword">be</span> committed)</span><br><span class="line">  (use <span class="string">&quot;git checkout -- &lt;file&gt;...&quot;</span> <span class="keyword">to</span> discard <span class="keyword">changes</span> in working directory)</span><br><span class="line"></span><br><span class="line">	deleted:    test.txt</span><br><span class="line"></span><br><span class="line"><span class="keyword">no</span> <span class="keyword">changes</span> added <span class="keyword">to</span> commit (use <span class="string">&quot;git add&quot;</span> <span class="built_in">and</span>/<span class="built_in">or</span> <span class="string">&quot;git commit -a&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>现在你有两个选择，一是确实要从版本库中删除该文件，那就用命令<code>git rm</code>删掉，并且<code>git commit</code>：</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">rm</span> <span class="keyword">test</span>.txt</span><br><span class="line"><span class="keyword">rm</span> &#x27;<span class="keyword">test</span>.txt&#x27;</span><br><span class="line"></span><br><span class="line">$ git commit -<span class="keyword">m</span> <span class="string">&quot;remove test.txt&quot;</span></span><br><span class="line">[master d46f35e] remove <span class="keyword">test</span>.txt</span><br><span class="line"> 1 <span class="keyword">file</span> changed, 1 deletion(-)</span><br><span class="line"> delete mode 100644 <span class="keyword">test</span>.txt</span><br></pre></td></tr></table></figure>
<p>现在，文件就从版本库中被删除了。</p>
<p> 小提示：先手动删除文件，然后使用git rm <file>和git add<file>效果是一样的。</p>
<p>另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本：</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><span class="line">$ git checkout <span class="comment">-- test.txt</span></span><br></pre></td></tr></table></figure>
<p><code>git checkout</code>其实是用版本库里的版本替换工作区的版本，无论工作区是修改还是删除，都可以“一键还原”。</p>
<p> 注意：从来没有被添加到版本库就被删除的文件，是无法恢复的！</p>
<p><strong>小结</strong></p>
<p>命令<code>git rm</code>用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失<strong>最近一次提交后你修改的内容</strong>。</p>
<h1 id="5-远程仓库"><a href="#5-远程仓库" class="headerlink" title="5 远程仓库"></a>5 远程仓库</h1><p>到目前为止，我们已经掌握了如何在Git仓库里对一个文件进行时光穿梭，你再也不用担心文件备份或者丢失的问题了。</p>
<p>可是有用过集中式版本控制系统SVN的童鞋会站出来说，这些功能在SVN里早就有了，没看出Git有什么特别的地方。</p>
<p>没错，如果只是在一个仓库里管理文件历史，Git和SVN真没啥区别。为了保证你现在所学的Git物超所值，将来绝对不会后悔，同时为了打击已经不幸学了SVN的童鞋，本章开始介绍Git的杀手级功能之一（注意是之一，也就是后面还有之二，之三……）：远程仓库。</p>
<p>Git是分布式版本控制系统，同一个Git仓库，可以分布到不同的机器上。怎么分布呢？最早，肯定只有一台机器有一个原始版本库，此后，别的机器可以“克隆”这个原始版本库，而且每台机器的版本库其实都是一样的，并没有主次之分。</p>
<p>你肯定会想，至少需要两台机器才能玩远程库不是？但是我只有一台电脑，怎么玩？</p>
<p>其实一台电脑上也是可以克隆多个版本库的，只要不在同一个目录下。不过，现实生活中是不会有人这么傻的在一台电脑上搞几个远程库玩，因为一台电脑上搞几个远程库完全没有意义，而且硬盘挂了会导致所有库都挂掉，所以我也不告诉你在一台电脑上怎么克隆多个仓库。</p>
<p>实际情况往往是这样，找一台电脑充当服务器的角色，每天24小时开机，其他每个人都从这个“服务器”仓库克隆一份到自己的电脑上，并且各自把各自的提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交。</p>
<p>完全可以自己搭建一台运行Git的服务器，不过现阶段，为了学Git先搭个服务器绝对是小题大作。好在这个世界上有个叫<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tLw==">GitHub<i class="fa fa-external-link-alt"></i></span>的神奇的网站，从名字就可以看出，这个网站就是提供Git仓库托管服务的，所以，只要注册一个GitHub账号，就可以免费获得Git远程仓库。</p>
<p>在继续阅读后续内容前，请自行注册GitHub账号。由于你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以，需要一点设置：</p>
<p>第1步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有<code>id_rsa</code>和<code>id_rsa.pub</code>这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>ssh-keygen -t rsa -C <span class="string">&quot;youremail@example.com&quot;</span></span><br></pre></td></tr></table></figure>




<p>你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。</p>
<p>如果一切顺利的话，可以在用户主目录里找到<code>.ssh</code>目录，里面有<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件，这两个就是SSH Key的秘钥对，<code>id_rsa</code>是私钥，不能泄露出去，<code>id_rsa.pub</code>是公钥，可以放心地告诉任何人。</p>
<p>第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面：</p>
<p>然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴<code>id_rsa.pub</code>文件的内容：</p>
<p><img data-src="/images/%E4%B8%8D%E5%AD%A6%E5%BA%9F%E4%B9%8B%E2%80%94%E2%80%94git%E7%AF%87/0-20210519123527159.png" alt="github-addkey-1"></p>
<p>点“Add Key”，你就应该看到已经添加的Key：</p>
<p><img data-src="/images/%E4%B8%8D%E5%AD%A6%E5%BA%9F%E4%B9%8B%E2%80%94%E2%80%94git%E7%AF%87/0-20210519123527611.png" alt="github-addkey-2"></p>
<p>为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。</p>
<p>当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。</p>
<p>最后友情提示，在GitHub上免费托管的Git仓库，任何人都可以看到喔（但只有你自己才能改）。所以，不要把敏感信息放进去。</p>
<p>如果你不想让别人看到Git库，有两个办法，一个是交点保护费，让GitHub把公开的仓库变成私有的，这样别人就看不见了（不可读更不可写）。另一个办法是自己动手，搭一个Git服务器，因为是你自己的Git服务器，所以别人也是看不见的。这个方法我们后面会讲到的，相当简单，公司内部开发必备。</p>
<p>确保你拥有一个GitHub账号后，我们就即将开始远程仓库的学习。</p>
<h3 id="添加远程库"><a href="#添加远程库" class="headerlink" title="添加远程库"></a>添加远程库</h3><p>现在的情景是，你已经在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作，真是一举多得。</p>
<p>首先，登陆GitHub，然后，在右上角找到“Create a new repo”按钮，创建一个新的仓库：</p>
<p><img data-src="/images/%E4%B8%8D%E5%AD%A6%E5%BA%9F%E4%B9%8B%E2%80%94%E2%80%94git%E7%AF%87/0-20210519123605857.png" alt="github-create-repo-1"></p>
<p>在Repository name填入<code>learngit</code>，其他保持默认设置，点击“Create repository”按钮，就成功地创建了一个新的Git仓库：</p>
<p><img data-src="/images/%E4%B8%8D%E5%AD%A6%E5%BA%9F%E4%B9%8B%E2%80%94%E2%80%94git%E7%AF%87/0-20210519123605858.png" alt="github-create-repo-2"></p>
<p>目前，在GitHub上的这个<code>learngit</code>仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。</p>
<p>现在，我们根据GitHub的提示，在本地的<code>learngit</code>仓库下运行命令：</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line">$ git remote <span class="keyword">add</span><span class="bash"> origin git@github.com:michaelliao/learngit.git</span></span><br></pre></td></tr></table></figure>
<p>请千万注意，把上面的<code>michaelliao</code>替换成你自己的GitHub账户名，否则，你在本地关联的就是我的远程库，关联没有问题，但是你以后推送是推不上去的，因为你的SSH Key公钥不在我的账户列表中。</p>
<p>添加后，远程库的名字就是<code>origin</code>，这是Git默认的叫法，也可以改成别的，但是<code>origin</code>这个名字一看就知道是远程库。</p>
<p>下一步，就可以把本地库的所有内容推送到远程库上：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">$ git push -<span class="keyword">u</span> origin master</span><br><span class="line">Counting object<span class="variable">s:</span> <span class="number">20</span>, done.</span><br><span class="line">Delta compression using <span class="keyword">up</span> <span class="keyword">to</span> <span class="number">4</span> threads.</span><br><span class="line">Compressing object<span class="variable">s:</span> <span class="number">100</span>% (<span class="number">15</span>/<span class="number">15</span>), done.</span><br><span class="line">Writing object<span class="variable">s:</span> <span class="number">100</span>% (<span class="number">20</span>/<span class="number">20</span>), <span class="number">1.64</span> KiB | <span class="number">560.00</span> KiB/s, done.</span><br><span class="line">Total <span class="number">20</span> (delta <span class="number">5</span>), reused <span class="number">0</span> (delta <span class="number">0</span>)</span><br><span class="line">remote: Resolving delta<span class="variable">s:</span> <span class="number">100</span>% (<span class="number">5</span>/<span class="number">5</span>), done.</span><br><span class="line">To github.<span class="keyword">com</span>:michaelliao/learngit.git</span><br><span class="line"> * [<span class="keyword">new</span> branch]      master -&gt; master</span><br><span class="line">Branch <span class="string">&#x27;master&#x27;</span> <span class="keyword">set</span> <span class="keyword">up</span> <span class="keyword">to</span> track remote branch <span class="string">&#x27;master&#x27;</span> from <span class="string">&#x27;origin&#x27;</span>.</span><br></pre></td></tr></table></figure>
<p>把本地库的内容推送到远程，用<code>git push</code>命令，实际上是把当前分支<code>master</code>推送到远程。</p>
<p>由于远程库是空的，我们第一次推送<code>master</code>分支时，加上了<code>-u</code>参数，Git不但会把本地的<code>master</code>分支内容推送的远程新的<code>master</code>分支，还会把本地的<code>master</code>分支和远程的<code>master</code>分支关联起来，在以后的推送或者拉取时就可以简化命令。</p>
<p>推送成功后，可以立刻在GitHub页面中看到远程库的内容已经和本地一模一样：</p>
<p><img data-src="/images/%E4%B8%8D%E5%AD%A6%E5%BA%9F%E4%B9%8B%E2%80%94%E2%80%94git%E7%AF%87/0-20210519123606377.png" alt="github-repo"></p>
<p>从现在起，只要本地作了提交，就可以通过命令：</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">push</span> <span class="built_in">origin</span> master</span><br></pre></td></tr></table></figure>
<p>把本地<code>master</code>分支的最新修改推送至GitHub，现在，你就拥有了真正的分布式版本库！</p>
<p><strong>SSH警告</strong></p>
<p>当你第一次使用Git的<code>clone</code>或者<code>push</code>命令连接GitHub时，会得到一个警告：</p>
<figure class="highlight vbnet"><table><tr><td class="code"><pre><span class="line">The authenticity <span class="keyword">of</span> host <span class="comment">&#x27;github.com (xx.xx.xx.xx)&#x27; can&#x27;t be established.</span></span><br><span class="line">RSA <span class="keyword">key</span> fingerprint <span class="built_in">is</span> xx.xx.xx.xx.xx.</span><br><span class="line">Are you sure you want <span class="keyword">to</span> <span class="keyword">continue</span> connecting (yes/no)?</span><br></pre></td></tr></table></figure>
<p>这是因为Git使用SSH连接，而SSH连接在第一次验证GitHub服务器的Key时，需要你确认GitHub的Key的指纹信息是否真的来自GitHub的服务器，输入<code>yes</code>回车即可。</p>
<p>Git会输出一个警告，告诉你已经把GitHub的Key添加到本机的一个信任列表里了：</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">Warning: Permanently added <span class="string">&#x27;github.com&#x27;</span> (RSA) <span class="built_in">to</span> <span class="keyword">the</span> list <span class="keyword">of</span> known hosts.</span><br></pre></td></tr></table></figure>
<p>这个警告只会出现一次，后面的操作就不会有任何警告了。</p>
<p>如果你实在担心有人冒充GitHub服务器，输入<code>yes</code>前可以对照<span class="exturl" data-url="aHR0cHM6Ly9oZWxwLmdpdGh1Yi5jb20vYXJ0aWNsZXMvd2hhdC1hcmUtZ2l0aHViLXMtc3NoLWtleS1maW5nZXJwcmludHMv">GitHub的RSA Key的指纹信息<i class="fa fa-external-link-alt"></i></span>是否与SSH连接给出的一致。</p>
<h3 id="删除远程库"><a href="#删除远程库" class="headerlink" title="删除远程库"></a>删除远程库</h3><p>如果添加的时候地址写错了，或者就是想删除远程库，可以用<code>git remote rm &lt;name&gt;</code>命令。使用前，建议先用<code>git remote -v</code>查看远程库信息：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin  git@github<span class="selector-class">.com</span>:michaelliao/learn-git<span class="selector-class">.git</span> (fetch)</span><br><span class="line">origin  git@github<span class="selector-class">.com</span>:michaelliao/learn-git<span class="selector-class">.git</span> (push)</span><br></pre></td></tr></table></figure>
<p>然后，根据名字删除，比如删除<code>origin</code>：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> git remote <span class="built_in">rm</span> origin</span><br></pre></td></tr></table></figure>
<p>此处的“删除”其实是解除了本地和远程的绑定关系，并不是物理上删除了远程库。远程库本身并没有任何改动。要真正删除远程库，需要登录到GitHub，在后台页面找到删除按钮再删除。</p>
<p><strong>小结</strong></p>
<p>要关联一个远程库，使用命令<code>git remote add origin git@server-name:path/repo-name.git</code>；</p>
<p>关联一个远程库时必须给远程库指定一个名字，<code>origin</code>是默认习惯命名；</p>
<p>关联后，使用命令<code>git push -u origin master</code>第一次推送master分支的所有内容；</p>
<p>此后，每次本地提交后，只要有必要，就可以使用命令<code>git push origin master</code>推送最新修改；</p>
<p>分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了！</p>
<h3 id="从远程仓库克隆"><a href="#从远程仓库克隆" class="headerlink" title="从远程仓库克隆"></a>从远程仓库克隆</h3><p>上次我们讲了先有本地库，后有远程库的时候，如何关联远程库。</p>
<p>现在，假设我们从零开发，那么最好的方式是先创建远程库，然后，从远程库克隆。</p>
<p>首先，登陆GitHub，创建一个新的仓库，名字叫<code>gitskills</code>：</p>
<p><img data-src="/images/%E4%B8%8D%E5%AD%A6%E5%BA%9F%E4%B9%8B%E2%80%94%E2%80%94git%E7%AF%87/0-20210519123712308.png" alt="github-init-repo"></p>
<p>我们勾选<code>Initialize this repository with a README</code>，这样GitHub会自动为我们创建一个<code>README.md</code>文件。创建完毕后，可以看到<code>README.md</code>文件：</p>
<p><img data-src="/images/%E4%B8%8D%E5%AD%A6%E5%BA%9F%E4%B9%8B%E2%80%94%E2%80%94git%E7%AF%87/0-20210519123712133.png" alt="github-init-repo-2"></p>
<p>现在，远程库已经准备好了，下一步是用命令<code>git clone</code>克隆一个本地库：</p>
<figure class="highlight groovy"><table><tr><td class="code"><pre><span class="line">$ git clone git<span class="meta">@github</span>.<span class="attr">com:</span>michaelliao/gitskills.git</span><br><span class="line">Cloning into <span class="string">&#x27;gitskills&#x27;</span>...</span><br><span class="line"><span class="attr">remote:</span> Counting <span class="attr">objects:</span> <span class="number">3</span>, done.</span><br><span class="line"><span class="attr">remote:</span> Total <span class="number">3</span> (delta <span class="number">0</span>), reused <span class="number">0</span> (delta <span class="number">0</span>), pack-reused <span class="number">3</span></span><br><span class="line">Receiving <span class="attr">objects:</span> <span class="number">100</span>% (<span class="number">3</span>/<span class="number">3</span>), done.</span><br></pre></td></tr></table></figure>
<p>注意把Git库的地址换成你自己的，然后进入<code>gitskills</code>目录看看，已经有<code>README.md</code>文件了：</p>
<figure class="highlight powershell"><table><tr><td class="code"><pre><span class="line"><span class="variable">$</span> <span class="built_in">cd</span> gitskills</span><br><span class="line"><span class="variable">$</span> <span class="built_in">ls</span></span><br><span class="line">README.md</span><br></pre></td></tr></table></figure>


<p>如果有多个人协作开发，那么每个人各自从远程克隆一份就可以了。</p>
<p>你也许还注意到，GitHub给出的地址不止一个，还可以用<code>https://github.com/michaelliao/gitskills.git</code>这样的地址。实际上，Git支持多种协议，默认的<code>git://</code>使用ssh，但也可以使用<code>https</code>等其他协议。</p>
<p>使用<code>https</code>除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用<code>ssh</code>协议而只能用<code>https</code>。</p>
<p><strong>小结</strong></p>
<p>要克隆一个仓库，首先必须知道仓库的地址，然后使用<code>git clone</code>命令克隆。</p>
<p>Git支持多种协议，包括<code>https</code>，但<code>ssh</code>协议速度最快。</p>
<h1 id="6-分支管理"><a href="#6-分支管理" class="headerlink" title="6 分支管理"></a>6 分支管理</h1><h3 id="创建与合并分支"><a href="#创建与合并分支" class="headerlink" title="创建与合并分支"></a>创建与合并分支</h3><p>在<span class="exturl" data-url="aHR0cHM6Ly93d3cubGlhb3h1ZWZlbmcuY29tL3dpa2kvODk2MDQzNDg4MDI5NjAwLzg5NzAxMzU3MzUxMjE5Mg==">版本回退<i class="fa fa-external-link-alt"></i></span>里，你已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即<code>master</code>分支。<code>HEAD</code>严格来说不是指向提交，而是指向<code>master</code>，<code>master</code>才是指向提交的，所以，<code>HEAD</code>指向的就是当前分支。</p>
<p>一开始的时候，<code>master</code>分支是一条线，Git用<code>master</code>指向最新的提交，再用<code>HEAD</code>指向<code>master</code>，就能确定当前分支，以及当前分支的提交点：</p>
<p><img data-src="/images/%E4%B8%8D%E5%AD%A6%E5%BA%9F%E4%B9%8B%E2%80%94%E2%80%94git%E7%AF%87/0-20210519125411586.png" alt="git-br-initial"></p>
<p>每次提交，<code>master</code>分支都会向前移动一步，这样，随着你不断提交，<code>master</code>分支的线也越来越长。</p>
<p>当我们创建新的分支，例如<code>dev</code>时，Git新建了一个指针叫<code>dev</code>，指向<code>master</code>相同的提交，再把<code>HEAD</code>指向<code>dev</code>，就表示当前分支在<code>dev</code>上：</p>
<p><img data-src="/images/%E4%B8%8D%E5%AD%A6%E5%BA%9F%E4%B9%8B%E2%80%94%E2%80%94git%E7%AF%87/l.png" alt="git-br-create"></p>
<p>你看，Git创建一个分支很快，因为除了增加一个<code>dev</code>指针，改改<code>HEAD</code>的指向，工作区的文件都没有任何变化！</p>
<p>不过，从现在开始，对工作区的修改和提交就是针对<code>dev</code>分支了，比如新提交一次后，<code>dev</code>指针往前移动一步，而<code>master</code>指针不变：</p>
<p><img data-src="/images/%E4%B8%8D%E5%AD%A6%E5%BA%9F%E4%B9%8B%E2%80%94%E2%80%94git%E7%AF%87/l-20210519125411582.png" alt="git-br-dev-fd"></p>
<p>假如我们在<code>dev</code>上的工作完成了，就可以把<code>dev</code>合并到<code>master</code>上。Git怎么合并呢？最简单的方法，就是直接把<code>master</code>指向<code>dev</code>的当前提交，就完成了合并：</p>
<p><img data-src="/images/%E4%B8%8D%E5%AD%A6%E5%BA%9F%E4%B9%8B%E2%80%94%E2%80%94git%E7%AF%87/0-20210519125411594.png" alt="git-br-ff-merge"></p>
<p>所以Git合并分支也很快！就改改指针，工作区内容也不变！</p>
<p>合并完分支后，甚至可以删除<code>dev</code>分支。删除<code>dev</code>分支就是把<code>dev</code>指针给删掉，删掉后，我们就剩下了一条<code>master</code>分支：</p>
<p><img data-src="/images/%E4%B8%8D%E5%AD%A6%E5%BA%9F%E4%B9%8B%E2%80%94%E2%80%94git%E7%AF%87/0-20210519125411595-1400051.png" alt="git-br-rm"></p>
<p>真是太神奇了，你看得出来有些提交是通过分支完成的吗？</p>
<p>下面开始实战。</p>
<p>首先，我们创建<code>dev</code>分支，然后切换到<code>dev</code>分支：</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">$ git checkout -b dev</span><br><span class="line">Switched <span class="built_in">to</span> <span class="keyword">a</span> <span class="built_in">new</span> branch <span class="string">&#x27;dev&#x27;</span></span><br></pre></td></tr></table></figure>
<p><code>git checkout</code>命令加上<code>-b</code>参数表示创建并切换，相当于以下两条命令：</p>
<figure class="highlight elixir"><table><tr><td class="code"><pre><span class="line"><span class="variable">$ </span>git branch dev</span><br><span class="line"><span class="variable">$ </span>git checkout dev</span><br><span class="line">Switched to branch <span class="string">&#x27;dev&#x27;</span></span><br></pre></td></tr></table></figure>
<p>然后，用<code>git branch</code>命令查看当前分支：</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="symbol">$</span> git branch</span><br><span class="line"><span class="comment">* dev</span></span><br><span class="line">  master</span><br></pre></td></tr></table></figure>
<p><code>git branch</code>命令会列出所有分支，当前分支前面会标一个<code>*</code>号。</p>
<p>然后，我们就可以在<code>dev</code>分支上正常提交，比如对<code>readme.txt</code>做个修改，加上一行：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">Creating a <span class="keyword">new</span> branch <span class="keyword">is</span> quick.</span><br></pre></td></tr></table></figure>
<p>然后提交：</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="symbol">$</span> git add readme.txt </span><br><span class="line"><span class="symbol">$</span> git commit -m <span class="string">&quot;branch test&quot;</span></span><br><span class="line">[dev b17d20e] branch test</span><br><span class="line"> <span class="number">1</span> <span class="keyword">file</span> changed, <span class="number">1</span> insertion(+)</span><br></pre></td></tr></table></figure>
<p>现在，<code>dev</code>分支的工作完成，我们就可以切换回<code>master</code>分支：</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">$ git checkout <span class="literal">master</span></span><br><span class="line">Switched to branch &#x27;<span class="literal">master</span>&#x27;</span><br></pre></td></tr></table></figure>
<p>切换回<code>master</code>分支后，再查看一个<code>readme.txt</code>文件，刚才添加的内容不见了！因为那个提交是在<code>dev</code>分支上，而<code>master</code>分支此刻的提交点并没有变：</p>
<p><img data-src="/images/%E4%B8%8D%E5%AD%A6%E5%BA%9F%E4%B9%8B%E2%80%94%E2%80%94git%E7%AF%87/0-20210519125411595.png" alt="git-br-on-master"></p>
<p>现在，我们把<code>dev</code>分支的工作成果合并到<code>master</code>分支上：</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="symbol">$</span> git merge dev</span><br><span class="line"><span class="function"><span class="title">Updating</span></span> d46f35e..b17d20e</span><br><span class="line">Fast-forward</span><br><span class="line"> readme.txt | <span class="number">1</span> +</span><br><span class="line"> <span class="number">1</span> <span class="keyword">file</span> changed, <span class="number">1</span> insertion(+)</span><br></pre></td></tr></table></figure>
<p><code>git merge</code>命令用于合并指定分支到当前分支。合并后，再查看<code>readme.txt</code>的内容，就可以看到，和<code>dev</code>分支的最新提交是完全一样的。</p>
<p>注意到上面的<code>Fast-forward</code>信息，Git告诉我们，这次合并是“快进模式”，也就是直接把<code>master</code>指向<code>dev</code>的当前提交，所以合并速度非常快。</p>
<p>当然，也不是每次合并都能<code>Fast-forward</code>，我们后面会讲其他方式的合并。</p>
<p>合并完成后，就可以放心地删除<code>dev</code>分支了：</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">branch </span>-d dev</span><br><span class="line">Deleted <span class="keyword">branch </span>dev (was <span class="keyword">b17d20e).</span></span><br></pre></td></tr></table></figure>
<p>删除后，查看<code>branch</code>，就只剩下<code>master</code>分支了：</p>
<figure class="highlight gams"><table><tr><td class="code"><pre><span class="line"><span class="symbol">$</span> git branch</span><br><span class="line"><span class="comment">* master</span></span><br></pre></td></tr></table></figure>
<p>因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在<code>master</code>分支上工作效果是一样的，但过程更安全。</p>
<p><strong>switch</strong></p>
<p>我们注意到切换分支使用<code>git checkout &lt;branch&gt;</code>，而前面讲过的撤销修改则是<code>git checkout -- &lt;file&gt;</code>，同一个命令，有两种作用，确实有点令人迷惑。</p>
<p>实际上，切换分支这个动作，用<code>switch</code>更科学。因此，最新版本的Git提供了新的<code>git switch</code>命令来切换分支：</p>
<p>创建并切换到新的<code>dev</code>分支，可以使用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">switch</span> -c dev</span><br></pre></td></tr></table></figure>
<p>直接切换到已有的<code>master</code>分支，可以使用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">switch</span> master</span><br></pre></td></tr></table></figure>
<p>使用新的<code>git switch</code>命令，比<code>git checkout</code>要更容易理解。</p>
<p><strong>小结</strong></p>
<p>Git鼓励大量使用分支：</p>
<p>查看分支：<code>git branch</code></p>
<p>创建分支：<code>git branch &lt;name&gt;</code></p>
<p>切换分支：<code>git checkout &lt;name&gt;</code>或者<code>git switch &lt;name&gt;</code></p>
<p>创建+切换分支：<code>git checkout -b &lt;name&gt;</code>或者<code>git switch -c &lt;name&gt;</code></p>
<p>合并某分支到当前分支：<code>git merge &lt;name&gt;</code></p>
<p>删除分支：<code>git branch -d &lt;name&gt;</code></p>
<h3 id="分支冲突"><a href="#分支冲突" class="headerlink" title="分支冲突"></a>分支冲突</h3><p>人生不如意之事十之八九，合并分支往往也不是一帆风顺的。</p>
<p>准备新的<code>feature1</code>分支，继续我们的新分支开发：</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">switch</span> -c feature1</span><br><span class="line">Switched <span class="built_in">to</span> <span class="keyword">a</span> <span class="built_in">new</span> branch <span class="string">&#x27;feature1&#x27;</span></span><br></pre></td></tr></table></figure>
<p>修改<code>readme.txt</code>最后一行，改为：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">Creating a <span class="keyword">new</span> branch <span class="keyword">is</span> quick AND simple.</span><br></pre></td></tr></table></figure>
<p>在<code>feature1</code>分支上提交：</p>
<figure class="highlight sas"><table><tr><td class="code"><pre><span class="line">$ git <span class="meta">add</span> readme.txt</span><br><span class="line"></span><br><span class="line">$ git commit -m <span class="string">&quot;AND simple&quot;</span></span><br><span class="line">[feature1 14096d0] <span class="meta">AND</span> simple</span><br><span class="line"> 1 <span class="meta">file</span> changed, 1 inserti<span class="meta">on(</span>+), 1 deleti<span class="meta">on(</span>-)</span><br></pre></td></tr></table></figure>
<p>切换到<code>master</code>分支：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">$ git switch master</span><br><span class="line">Switched <span class="keyword">to</span> branch <span class="string">&#x27;master&#x27;</span></span><br><span class="line">Your branch <span class="keyword">is</span> ahead <span class="keyword">of</span> <span class="string">&#x27;origin/master&#x27;</span> <span class="keyword">by</span> <span class="number">1</span> <span class="keyword">commit</span>.</span><br><span class="line">  (use &quot;git push&quot; <span class="keyword">to</span> publish your <span class="keyword">local</span> commits)</span><br></pre></td></tr></table></figure>
<p>Git还会自动提示我们当前<code>master</code>分支比远程的<code>master</code>分支要超前1个提交。</p>
<p>在<code>master</code>分支上把<code>readme.txt</code>文件的最后一行改为：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">Creating a <span class="keyword">new</span> branch <span class="keyword">is</span> quick &amp; simple.</span><br></pre></td></tr></table></figure>
<p>提交：</p>
<figure class="highlight sas"><table><tr><td class="code"><pre><span class="line">$ git <span class="meta">add</span> readme.txt </span><br><span class="line">$ git commit -m <span class="string">&quot;&amp; simple&quot;</span></span><br><span class="line">[master 5dc6824] &amp; simple</span><br><span class="line"> 1 <span class="meta">file</span> changed, 1 inserti<span class="meta">on(</span>+), 1 deleti<span class="meta">on(</span>-)</span><br></pre></td></tr></table></figure>
<p>现在，<code>master</code>分支和<code>feature1</code>分支各自都分别有新的提交，变成了这样：</p>
<p><img data-src="https://www.liaoxuefeng.com/files/attachments/919023000423040/0" alt="git-br-feature1"></p>
<p>这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，我们试试看：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">$ git merge feature1</span><br><span class="line">Auto-merging readme.txt</span><br><span class="line"><span class="keyword">CONFLICT</span> (content): Merge <span class="keyword">conflict</span> <span class="keyword">in</span> readme.txt</span><br><span class="line">Automatic merge failed; fix conflicts <span class="keyword">and</span> <span class="keyword">then</span> <span class="keyword">commit</span> the result.</span><br></pre></td></tr></table></figure>
<p>果然冲突了！Git告诉我们，<code>readme.txt</code>文件存在冲突，必须手动解决冲突后再提交。<code>git status</code>也可以告诉我们冲突的文件：</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line"><span class="keyword">On</span> branch master</span><br><span class="line">Your branch is ahead of &#x27;origin/master&#x27; <span class="keyword">by</span> 2 commits.</span><br><span class="line">  (<span class="keyword">use</span> <span class="string">&quot;git push&quot;</span> to publish your <span class="keyword">local</span> commits)</span><br><span class="line"></span><br><span class="line">You have unmerged paths.</span><br><span class="line">  (fix conflicts and <span class="keyword">run</span> <span class="string">&quot;git commit&quot;</span>)</span><br><span class="line">  (<span class="keyword">use</span> <span class="string">&quot;git merge --abort&quot;</span> to abort the <span class="keyword">merge</span>)</span><br><span class="line"></span><br><span class="line">Unmerged paths:</span><br><span class="line">  (<span class="keyword">use</span> <span class="string">&quot;git add &lt;file&gt;...&quot;</span> to <span class="keyword">mark</span> resolution)</span><br><span class="line"></span><br><span class="line">	both modified:   readme.txt</span><br><span class="line"></span><br><span class="line"><span class="keyword">no</span> changes added to commit (<span class="keyword">use</span> <span class="string">&quot;git add&quot;</span> and/or <span class="string">&quot;git commit -a&quot;</span>)</span><br></pre></td></tr></table></figure>
<p>我们可以直接查看readme.txt的内容：</p>
<figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">Git <span class="keyword">is</span> <span class="keyword">a</span> distributed <span class="keyword">version</span> control <span class="built_in">system</span>.</span><br><span class="line">Git <span class="keyword">is</span> free software distributed under the GPL.</span><br><span class="line">Git <span class="built_in">has</span> <span class="keyword">a</span> mutable <span class="built_in">index</span> called stage.</span><br><span class="line">Git tracks <span class="keyword">changes</span> of <span class="keyword">files</span>.</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">Creating <span class="keyword">a</span> <span class="keyword">new</span> branch <span class="keyword">is</span> quick &amp; simple.</span><br><span class="line">=======</span><br><span class="line">Creating <span class="keyword">a</span> <span class="keyword">new</span> branch <span class="keyword">is</span> quick AND simple.</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1</span><br></pre></td></tr></table></figure>
<p>Git用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容，我们修改内容（并且删除标记）：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><span class="line">Creating a <span class="keyword">new</span> branch <span class="keyword">is</span> quick and simple.</span><br></pre></td></tr></table></figure>
<p>再提交：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">add</span> readme.txt </span><br><span class="line">$ git <span class="keyword">commit</span> -m &quot;conflict fixed&quot;</span><br><span class="line">[master cf810e4] <span class="keyword">conflict</span> fixed</span><br></pre></td></tr></table></figure>
<p>现在，<code>master</code>分支和<code>feature1</code>分支变成了下图所示：</p>
<p><img data-src="/images/%E4%B8%8D%E5%AD%A6%E5%BA%9F%E4%B9%8B%E2%80%94%E2%80%94git%E7%AF%87/0-20210519125453421.png" alt="git-br-conflict-merged"></p>
<p>用带参数的<code>git log</code>也可以看到分支的合并情况：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">log</span> <span class="comment">--graph --pretty=oneline --abbrev-commit</span></span><br><span class="line">*   cf810e4 (HEAD -&gt; master) <span class="keyword">conflict</span> fixed</span><br><span class="line">|\  </span><br><span class="line">| * <span class="number">14096</span>d0 (feature1) <span class="keyword">AND</span> simple</span><br><span class="line">* | <span class="number">5</span>dc6824 &amp; simple</span><br><span class="line">|/  </span><br><span class="line">* b17d20e branch test</span><br><span class="line">* d46f35e (origin/master) remove test.txt</span><br><span class="line">* b84166e <span class="keyword">add</span> test.txt</span><br><span class="line">* <span class="number">519219</span>b git tracks changes</span><br><span class="line">* e43a48b understand how stage works</span><br><span class="line">* <span class="number">1094</span>adb append GPL</span><br><span class="line">* e475afc <span class="keyword">add</span> distributed</span><br><span class="line">* eaadf4e wrote a readme file</span><br></pre></td></tr></table></figure>
<p>最后，删除<code>feature1</code>分支：</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><span class="line">$ git <span class="keyword">branch </span>-d feature1</span><br><span class="line">Deleted <span class="keyword">branch </span>feature1 (was <span class="number">14096</span>d0).</span><br></pre></td></tr></table></figure>
<p>工作完成。</p>
<p><strong>小结</strong></p>
<p>当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。</p>
<p>解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。</p>
<p>用<code>git log --graph</code>命令可以看到分支合并图。</p>
<h3 id="【待续】"><a href="#【待续】" class="headerlink" title="【待续】"></a>【待续】</h3><p>参考：<br><span class="exturl" data-url="aHR0cHM6Ly93d3cubGlhb3h1ZWZlbmcuY29tL3dpa2kvODk2MDQzNDg4MDI5NjAwLzg5Njk1NDA3NDY1OTAwOA==">https://www.liaoxuefeng.com/wiki/896043488029600/896954074659008<i class="fa fa-external-link-alt"></i></span></p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
</search>
