---
title: Flink从入门到放弃01——Flink简介
typora-root-url: ../../source
date: 2021-12-08 10:37:21
tags: Flink
categories: BigData
sticky:
---

Apache Flink是一个面向数据流处理和批量数据处理的可分布式的开源计算框架，它基于同一个Flink流式执行模型（streaming execution model），能够支持流处理和批处理两种应用类型。由于流处理和批处理所提供的SLA(服务等级协议)是完全不相同， 流处理一般需要支持低延迟、Exactly-once保证，而批处理需要支持高吞吐、高效处理，所以在实现的时候通常是分别给出两套实现方法，或者通过一个独立的开源框架来实现其中每一种处理方案。

<!-- more -->

# Flink是什么

Apache flink前身是柏林理工大学一个研究性项目， 在 2014 被 Apache 孵化器接收，然后迅速地成为了Apache Software Foundation的顶级项目之一。

> Apache Flink is a framework and ***distributed*** processing engine for ***stateful*** computations over ***unbounded and bounded*** data ***streams***.



# 为什么选择Flink

## 传统数据处理架构

大多数企业实施的传统架构区分了两种类型的数据处理模式：数据事务处理和数据分析处理。两种架构分别面向不同的功能需求，适用于不同场景，具有各自的优势和局限

### 事务处理架构

事务处理架构中，各种应用程序分别由单独的层编写，如用户关系关系CRM、订单系统、web应用。应用程序通常连接到外部服务或直接面向用户，并持续处理传入的事件，如网站上的订单，电子邮件或点击。处理事件时，**应用程序将会读取远程数据库的状态，或者通过运行事务来更新它**。通常，一个数据库系统被多个应用程序共用。

这种架构的优势是，对于用户产生的事件可以进行快速的响应，事件来一个处理一个，**低时延**，但是由于后台共用一个远程数据库，**当数据越来越庞大的时候代价会很高，并且扩展性不好**。应用程序可以通过分布式处理来解决，但是对于需要综合数据实现分析类功能时，关系型数据库的联表查询会出问题。

<img src="/images/Flink%E4%BB%8E0%E5%88%B01%EF%BC%9A01-Flink%E7%AE%80%E4%BB%8B/spaf_0101.png" alt="img" style="zoom:50%;" />

### 分析处理架构

事务数据通常分布在多个数据库中，往往汇总起来联合分析时更有价值。所以我们一般不会直接在事务数据库上运行分析查询，而是复制数据到数据仓库。数据仓库是对工作负载进行分析和查询的专用数据存储。为了填充数据仓库，需要将事务数据库系统管理的数据复制过来。**将数据复制到数据仓库的过程称为extract-transform-load（ETL）**。 ETL过程从事务数据库中提取数据，将其转换为某种通用的结构表示，可能包括验证，值的规范化，编码，重复数据删除（去重）和模式转换，最后将其加载到分析数据库中。 ETL过程可能非常复杂，并且通常需要技术复杂的解决方案来满足性能要求。 ETL过程需要定期运行以保持数据仓库中的数据同步。

数据仓库上的查询类型有两种：**第一种类型是定期报告查询**，用于计算与业务相关的统计信息。**第二种类型是即席查询**，旨在提供特定问题的答案并支持关键业务决策。两种查询由批处理方式由数据仓库执行。

这种架构的问题很明显，**实时性较差**，不适用于延迟要求低的事务处理要求。

<img src="https://confucianzuoyuan.github.io/flink-tutorial/book/images/spaf_0103.png" alt="img" style="zoom: 50%;" />

## 流处理架构

流处理的目标就是模拟真实情况下的数据特点，同时满足低延迟、高吞吐的数据处理要求。

### 有状态的流处理

有状态的流处理方式将数据的中间状态直接存储在内存当中，处理过程中，不需要进行反复写入和更新远程数据库，而直接基于内存存储状态完成计算。由于保存在内存中的状态（local state）容易丢失，可以依靠定期将应用程序状态的一致性检查点（check point）写入远程且持久的存储。因此同时具备**高吞吐、低延迟、可靠**的特定。

<img src="https://confucianzuoyuan.github.io/flink-tutorial/book/images/spaf_0104.png" alt="img" style="zoom:50%;" />

### lambda架构

基于有状态流处理方案设计的第一代分布式开源流处理器（2011），专注于具有毫秒延迟的事件处理，并提供了在发生故障时防止事件丢失的保证。这些系统具有相当低级的API，并且对于流应用程序的准确性和结果的一致性，不提供内置支持，因为结果会取决于到达事件的时间和顺序。另外，即使事件没有丢失，也可能不止一次地处理它们。**与批处理器相比，第一代开源流处理器牺牲了结果准确性，用来获得更低的延迟**。为了让当时的数据处理系统，可以同时提供快速和准确的结果，设计了lambda架构。

<img src="https://confucianzuoyuan.github.io/flink-tutorial/book/images/spaf_0107.png" alt="img" style="zoom:50%;" />

批处理器定期处理批量存储中的数据，将准确的结果写入批处理表，并从速度表中删除相应的不准确结果。应用程序会合并快速表中的近似结果和批处理表中的准确结果，然后消费最终的结果。

这种架构的问题在于，每个功能都需要实现两个独立的、具有不同API的处理系统，难以建立和维护。

## flink架构特点

### 主要特点

- 事件驱动 Event-drive

  **事件驱动的应用程序**是有状态的应用程序，它从一个或多个事件中提取事件，并通过触发计算，状态更新或外部操作来对传入的事件做出反应。

  <img src="/images/Flink%E4%BB%8E0%E5%88%B01%EF%BC%9A01-Flink%E7%AE%80%E4%BB%8B/image-20211208142135187.png" alt="image-20211208142135187" style="zoom: 67%;" />

- 基于流的世界观

  一切都是由流组成的，**离线数据是有界的流;实时数据是一个没有界限的流**

- 分层API

  - 越顶层越抽象，表达含义越简明，使用越方便
  - 越底层越具体，表达能力越丰富，使用越灵活

  <img src="/images/Flink%E4%BB%8E0%E5%88%B01%EF%BC%9A01-Flink%E7%AE%80%E4%BB%8B/image-20211208142557976.png" alt="image-20211208142557976" style="zoom:50%;" />

### 其他特点

- 支持事件时间（event-time）和处理时间(processing-time)语义

  - **`Processing Time`(处理时间)是指执行相应操作的机器系统时间**，是操作算子在计算过程中获取到的所在主机的系统时间。当用户选择使用处理时间时，所有和时间相关的算子，例如 Windows 计算，在当前任务中所有的算子直接使用所在主机的系统时间。例如，一个基于处理时间按每小时进行处理的时间窗口将处理一个小时内（以系统时间为标准）到达指定算子的所有的记录。

    处理时间是最简单的一个时间概念，不需要在数据流和机器之间进行协调。具有最好的性能和最低的延迟。然而，在分布式或者异步环境中，处理时间具有不确定性，因为容易受到记录到达系统速度的影响(例如，从消息队列到达的记录)，还会受到系统内记录在不同算子之间的流动速度的影响。对数据乱序的处理，处理时间不是一种最优的选择。总之，**处理时间适用于时间计算精度要求不是特别高的计算场景**。

  - **`Event Time`(事件时间)是每个事件在产生它的设备上发生的时间。****在进入 Flink 之前，事件时间通常要嵌入到记录中，并且事件时间也可以从记录中提取出来。对于事件时间，时间的进度取决于数据，而不是系统时钟。基于事件时间的程序必须指定如何生成事件时间的`Watermarks`，这是表示事件时间进度的机制。

    在理想情况下，事件时间处理将产生完全一致且确定的结果，无论事件何时到达以及以什么样的顺序到达。但是，除非已知事件是按顺序（按时间戳）到达，否则事件时间处理在等待无序事件时产生一定的延迟。由于只能等待有限的时间，因此这限制了事件时间应用程序的确定性。

    假定所有数据都已到达，事件时间算子将按预期方式运行，即使在处理无序、迟到事件或重新处理历史数据时，也会产生正确且一致的结果。例如，每小时事件时间窗口将将处理事件时间在这一小时之内所有的记录，不管它们何时到达，以及它们以什么顺序到达。

    **按事件时间处理往往会导致一定的延迟，因为它要等待延迟事件和无序事件一段时间。因此，事件时间程序通常与处理时间操作相结合使用。**

- 精确一次(exactly-once)的状态一致性保证
  - **状态**：为了产生一个结果，函数一般会聚合某个时间段内（或是一定数量的）events的状态信息（例如计算聚合值，或是发现一个模式），有状态的 operators使用流的输入事件以及内部状态，计算出它们的输出。**例如，一个滚动聚合operator输出当前它读入的所有的events的总和。Operator 持有当前sum的值作为它的内部状态，并在每次读入新值时对它做更新。**
  - **exactly-once**：流处理系统通过提供结果保障（result guarantees）定义任务在故障发生时的行为。主流流处理器提供的保障（guarantees）包括**至多一次at-most-once、至少一次（AT-LEAST-ONCE）、精确一次（EXACTLY-ONCE）**等。exactly-once是最严个保障。
- 低延迟，每秒处理数百万个事件，毫秒级延迟
- 与众多常用存储系统的连接
- 高可用，动态扩展，实现7*24小时全天候运行

### Flink & Spark streaming

- spark streaming 本质是微批处理，flink是真正的流处理平台
- spark采用RDD(弹性分布式算子)，flink基本数据模型是数据流
- spark是批计算，将DAG划分成不同的stage，（一个单位的）所有数据完成一个stage才能开始下一个，有一定的延迟；flink一个事件在一个节点处理完成后可以直接发往下一个

# Reference

传统架构演进 https://blog.csdn.net/wannuoge4766/article/details/94484263
教程视频 https://www.bilibili.com/video/BV1qy4y1q728?p=4
flink教程文档 https://confucianzuoyuan.github.io/flink-tutorial/book/
时间时间 http://smartsi.club/flink-stream-event-time-and-processing-time.html
状态一致 https://www.cnblogs.com/zackstang/p/10850023.html

